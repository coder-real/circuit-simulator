<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Circuit Simulator — tsk-102</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      :root {
        --color-bg-app: #080c14;
        --color-bg-toolbar: #0d1117;
        --color-bg-canvas: #0a0e1a;
        --color-bg-panel: #0d1117;
        --color-bg-card: #131b2e;
        --color-bg-card-hover: #1a2744;
        --color-bg-modal: #111827;
        --color-bg-input: #0d1117;
        --color-bg-tooltip: #1e293b;
        --color-canvas-dot: rgba(96, 165, 250, 0.18);
        --color-border-subtle: #1a2235;
        --color-border-default: #1f2d45;
        --color-border-strong: #2d4263;
        --color-text-primary: #e8f0fe;
        --color-text-secondary: #7e9cc4;
        --color-text-disabled: #3b506e;
        --color-accent: #4f8ef7;
        --color-accent-dark: #2563eb;
        --color-accent-light: #1d3461;
        --color-accent-glow: rgba(79, 142, 247, 0.3);
        --color-accent-glow-sm: rgba(79, 142, 247, 0.15);
        --color-success: #22c55e;
        --color-success-glow: rgba(34, 197, 94, 0.25);
        --color-warning: #f59e0b;
        --color-warning-glow: rgba(245, 158, 11, 0.25);
        --color-danger: #ef4444;
        --color-danger-glow: rgba(239, 68, 68, 0.25);
        --color-comp-resistor: #60a5fa;
        --color-comp-vsource: #f59e0b;
        --color-comp-led: #22c55e;
        --color-comp-switch: #94a3b8;
        --color-comp-switch-on: #22c55e;
        --color-comp-ground: #64748b;
        --font-ui: "Syne", sans-serif;
        --font-mono: "JetBrains Mono", monospace;
        --text-2xs: 10px;
        --text-xs: 11px;
        --text-sm: 13px;
        --text-base: 15px;
        --text-lg: 17px;
        --text-xl: 20px;
        --sp-1: 4px;
        --sp-2: 8px;
        --sp-3: 12px;
        --sp-4: 16px;
        --sp-5: 20px;
        --sp-6: 24px;
        --sp-8: 32px;
        --radius-xs: 3px;
        --radius-sm: 5px;
        --radius-md: 8px;
        --radius-lg: 12px;
        --radius-xl: 16px;
        --radius-pill: 999px;
        --shadow-sm: 0 1px 4px rgba(0, 0, 0, 0.5);
        --shadow-md: 0 4px 14px rgba(0, 0, 0, 0.6);
        --shadow-lg: 0 8px 28px rgba(0, 0, 0, 0.7);
        --shadow-glow: 0 0 18px var(--color-accent-glow);
        --shadow-glow-sm: 0 0 10px var(--color-accent-glow-sm);
        --transition-fast: 0.12s ease;
        --transition-base: 0.2s ease;
        --transition-slow: 0.35s ease;
        --toolbar-height: 52px;
        --panel-width: 280px;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: var(--color-bg-app);
        color: var(--color-text-primary);
        font-family: var(--font-ui);
        -webkit-font-smoothing: antialiased;
      }
      .app-shell {
        display: grid;
        grid-template-rows: var(--toolbar-height) 1fr;
        grid-template-columns: 1fr var(--panel-width);
        grid-template-areas: "toolbar toolbar" "canvas panel";
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
      .toolbar {
        grid-area: toolbar;
        display: flex;
        align-items: center;
        gap: var(--sp-2);
        padding: 0 var(--sp-4);
        background: var(--color-bg-toolbar);
        border-bottom: 1px solid var(--color-border-default);
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
        position: relative;
        z-index: 100;
        user-select: none;
      }
      .toolbar-brand {
        display: flex;
        align-items: center;
        gap: var(--sp-2);
        margin-right: var(--sp-3);
      }
      .toolbar-brand-icon {
        width: 28px;
        height: 28px;
        background: var(--color-accent);
        border-radius: var(--radius-sm);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 15px;
        box-shadow: var(--shadow-glow-sm);
        flex-shrink: 0;
      }
      .toolbar-brand-name {
        font-size: var(--text-base);
        font-weight: 700;
        letter-spacing: 0.04em;
      }
      .toolbar-brand-badge {
        font-size: var(--text-2xs);
        font-weight: 600;
        letter-spacing: 0.08em;
        color: var(--color-accent);
        background: var(--color-accent-light);
        border: 1px solid var(--color-accent);
        border-radius: var(--radius-pill);
        padding: 1px 6px;
        text-transform: uppercase;
      }
      .toolbar-divider {
        width: 1px;
        height: 24px;
        background: var(--color-border-default);
        margin: 0 var(--sp-1);
        flex-shrink: 0;
      }
      .tool-group {
        display: flex;
        align-items: center;
        gap: var(--sp-1);
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--color-border-subtle);
        border-radius: var(--radius-md);
        padding: 3px;
      }
      .tool-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 5px 10px;
        border: none;
        border-radius: var(--radius-sm);
        background: transparent;
        color: var(--color-text-secondary);
        font-family: var(--font-ui);
        font-size: var(--text-sm);
        font-weight: 600;
        letter-spacing: 0.02em;
        cursor: pointer;
        transition:
          background var(--transition-fast),
          color var(--transition-fast),
          box-shadow var(--transition-fast);
        white-space: nowrap;
      }
      .tool-btn:hover {
        background: rgba(255, 255, 255, 0.06);
        color: var(--color-text-primary);
      }
      .tool-btn[data-tool="select"].active {
        background: var(--color-accent-light);
        color: var(--color-accent);
        box-shadow: inset 0 0 0 1px var(--color-accent);
      }
      .tool-btn[data-tool="wire"].active {
        background: rgba(52, 211, 153, 0.12);
        color: var(--color-success);
        box-shadow: inset 0 0 0 1px var(--color-success);
      }
      .tool-btn[data-tool="ground"].active {
        background: rgba(148, 163, 184, 0.12);
        color: var(--color-comp-ground);
        box-shadow: inset 0 0 0 1px var(--color-comp-ground);
      }
      .tool-btn svg {
        width: 14px;
        height: 14px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        flex-shrink: 0;
      }
      .wire-colors {
        display: flex;
        align-items: center;
        gap: var(--sp-1);
      }
      .wire-color-label {
        font-size: var(--text-xs);
        font-weight: 600;
        color: var(--color-text-disabled);
        letter-spacing: 0.05em;
        text-transform: uppercase;
        margin-right: 2px;
      }
      .color-swatch {
        width: 18px;
        height: 18px;
        border-radius: var(--radius-pill);
        border: 2px solid transparent;
        cursor: pointer;
        transition:
          transform var(--transition-fast),
          border-color var(--transition-fast),
          box-shadow var(--transition-fast);
      }
      .color-swatch:hover {
        transform: scale(1.2);
      }
      .color-swatch.active {
        border-color: #fff;
        box-shadow: 0 0 8px currentColor;
        transform: scale(1.15);
      }
      .toolbar-spacer {
        flex: 1;
      }
      .zoom-group {
        display: flex;
        align-items: center;
        gap: 2px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--color-border-subtle);
        border-radius: var(--radius-md);
        padding: 3px;
      }
      .zoom-btn {
        width: 28px;
        height: 28px;
        border: none;
        border-radius: var(--radius-xs);
        background: transparent;
        color: var(--color-text-secondary);
        font-family: var(--font-ui);
        font-size: var(--text-lg);
        font-weight: 700;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition:
          background var(--transition-fast),
          color var(--transition-fast);
      }
      .zoom-btn:hover {
        background: rgba(255, 255, 255, 0.07);
        color: var(--color-text-primary);
      }
      .zoom-level {
        font-family: var(--font-mono);
        font-size: var(--text-xs);
        font-weight: 500;
        color: var(--color-text-secondary);
        min-width: 38px;
        text-align: center;
      }
      .btn-clear {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border: 1px solid var(--color-border-default);
        border-radius: var(--radius-sm);
        background: transparent;
        color: var(--color-text-secondary);
        font-family: var(--font-ui);
        font-size: var(--text-sm);
        font-weight: 600;
        cursor: pointer;
        transition:
          border-color var(--transition-fast),
          color var(--transition-fast),
          background var(--transition-fast);
      }
      .btn-clear:hover {
        border-color: var(--color-danger);
        color: var(--color-danger);
        background: rgba(239, 68, 68, 0.08);
      }
      .btn-simulate {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 7px 18px;
        border: none;
        border-radius: var(--radius-sm);
        background: var(--color-accent);
        color: #fff;
        font-family: var(--font-ui);
        font-size: var(--text-sm);
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        cursor: pointer;
        transition:
          background var(--transition-fast),
          box-shadow var(--transition-fast),
          transform var(--transition-fast);
        position: relative;
        overflow: hidden;
      }
      .btn-simulate::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(255, 255, 255, 0.15) 50%,
          transparent 100%
        );
        transform: translateX(-100%);
        transition: transform 0.5s ease;
      }
      .btn-simulate:hover {
        background: var(--color-accent-dark);
        box-shadow: var(--shadow-glow);
        transform: translateY(-1px);
      }
      .btn-simulate:hover::before {
        transform: translateX(100%);
      }
      .btn-simulate.running {
        background: var(--color-accent-dark);
        animation: sim-pulse 1.2s ease-in-out infinite alternate;
      }
      .btn-simulate.has-results {
        background: var(--color-success);
      }
      .btn-simulate svg {
        width: 14px;
        height: 14px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2.5;
        stroke-linecap: round;
        stroke-linejoin: round;
        flex-shrink: 0;
      }
      @keyframes sim-pulse {
        from {
          box-shadow: 0 0 8px var(--color-accent-glow);
        }
        to {
          box-shadow: 0 0 24px var(--color-accent-glow);
        }
      }
      .canvas-wrap {
        grid-area: canvas;
        position: relative;
        overflow: hidden;
        background: var(--color-bg-canvas);
        box-shadow: inset 0 0 60px rgba(0, 0, 0, 0.3);
      }
      #circuit-canvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: default;
      }
      .canvas-wrap[data-mode="wire"] #circuit-canvas {
        cursor: crosshair;
      }
      .canvas-wrap[data-mode="pan"] #circuit-canvas {
        cursor: grabbing;
      }
      .canvas-coords {
        position: absolute;
        bottom: var(--sp-3);
        left: var(--sp-4);
        font-family: var(--font-mono);
        font-size: var(--text-xs);
        color: var(--color-text-disabled);
        pointer-events: none;
        user-select: none;
      }
      .canvas-status {
        position: absolute;
        top: var(--sp-4);
        left: var(--sp-4);
        display: flex;
        align-items: center;
        gap: 6px;
        font-family: var(--font-ui);
        font-size: var(--text-xs);
        font-weight: 600;
        color: var(--color-text-secondary);
        letter-spacing: 0.05em;
        text-transform: uppercase;
        background: rgba(13, 17, 23, 0.8);
        border: 1px solid var(--color-border-subtle);
        border-radius: var(--radius-pill);
        padding: 4px 10px;
        backdrop-filter: blur(6px);
        pointer-events: none;
        user-select: none;
      }
      .canvas-status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--color-text-disabled);
        flex-shrink: 0;
      }
      .canvas-status-dot.ready {
        background: var(--color-success);
        box-shadow: 0 0 6px var(--color-success-glow);
      }
      .canvas-status-dot.active {
        background: var(--color-warning);
        box-shadow: 0 0 6px var(--color-warning-glow);
        animation: blink 1s infinite;
      }
      .canvas-status-dot.error {
        background: var(--color-danger);
        box-shadow: 0 0 6px var(--color-danger-glow);
      }
      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }
      .toast-container {
        position: absolute;
        bottom: var(--sp-6);
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--sp-2);
        pointer-events: none;
        z-index: 200;
      }
      .toast {
        display: flex;
        align-items: center;
        gap: var(--sp-3);
        padding: var(--sp-3) var(--sp-5);
        background: var(--color-bg-modal);
        border: 1px solid var(--color-border-default);
        border-left: 4px solid var(--color-accent);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-lg);
        font-family: var(--font-ui);
        font-size: var(--text-sm);
        font-weight: 500;
        color: var(--color-text-primary);
        white-space: nowrap;
        backdrop-filter: blur(10px);
        opacity: 0;
        transform: translateY(16px);
        transition:
          opacity var(--transition-base),
          transform var(--transition-base);
      }
      .toast.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .toast.success {
        border-left-color: var(--color-success);
      }
      .toast.warning {
        border-left-color: var(--color-warning);
      }
      .toast.error {
        border-left-color: var(--color-danger);
      }
      .panel {
        grid-area: panel;
        display: flex;
        flex-direction: column;
        background: var(--color-bg-panel);
        border-left: 1px solid var(--color-border-strong);
        overflow: hidden;
        z-index: 50;
      }
      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--sp-3) var(--sp-4);
        border-bottom: 1px solid var(--color-border-subtle);
        flex-shrink: 0;
      }
      .panel-title {
        font-size: var(--text-sm);
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--color-text-secondary);
      }
      .panel-component-count {
        font-family: var(--font-mono);
        font-size: var(--text-xs);
        color: var(--color-text-disabled);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--color-border-subtle);
        border-radius: var(--radius-pill);
        padding: 1px 8px;
      }
      .panel-body {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: var(--sp-3);
        display: flex;
        flex-direction: column;
        gap: var(--sp-4);
      }
      .panel-body::-webkit-scrollbar {
        width: 4px;
      }
      .panel-body::-webkit-scrollbar-track {
        background: transparent;
      }
      .panel-body::-webkit-scrollbar-thumb {
        background: var(--color-border-default);
        border-radius: var(--radius-pill);
      }
      .component-section {
        display: flex;
        flex-direction: column;
        gap: var(--sp-2);
      }
      .component-section-title {
        font-size: var(--text-2xs);
        font-weight: 700;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: var(--color-text-disabled);
        padding: 0 var(--sp-1);
        margin-bottom: 2px;
      }
      .component-card {
        display: flex;
        align-items: center;
        gap: var(--sp-3);
        padding: var(--sp-3);
        background: var(--color-bg-card);
        border: 1px solid var(--color-border-subtle);
        border-radius: var(--radius-md);
        cursor: grab;
        user-select: none;
        transition:
          background var(--transition-fast),
          border-color var(--transition-fast),
          transform var(--transition-fast),
          box-shadow var(--transition-fast);
        position: relative;
        overflow: hidden;
      }
      .component-card::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 3px;
        background: var(--card-accent, var(--color-accent));
        border-radius: var(--radius-pill) 0 0 var(--radius-pill);
        opacity: 0;
        transition: opacity var(--transition-fast);
      }
      .component-card:hover {
        background: var(--color-bg-card-hover);
        border-color: var(--card-accent, var(--color-accent));
        transform: translateX(3px);
        box-shadow: var(--shadow-sm);
      }
      .component-card:hover::before {
        opacity: 1;
      }
      .component-card:active {
        cursor: grabbing;
        transform: scale(0.97);
      }
      .card-icon {
        width: 40px;
        height: 32px;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .card-icon svg {
        width: 38px;
        height: 28px;
        overflow: visible;
      }
      .card-info {
        flex: 1;
        min-width: 0;
      }
      .card-name {
        font-size: var(--text-sm);
        font-weight: 600;
        color: var(--color-text-primary);
      }
      .card-default {
        font-family: var(--font-mono);
        font-size: var(--text-xs);
        color: var(--color-text-secondary);
        margin-top: 2px;
      }
      .card-handle {
        color: var(--color-text-disabled);
        font-size: 14px;
        opacity: 0;
        transition: opacity var(--transition-fast);
      }
      .component-card:hover .card-handle {
        opacity: 1;
      }
      .properties-panel {
        border-top: 1px solid var(--color-border-default);
        background: var(--color-bg-app);
        flex-shrink: 0;
        max-height: 0;
        overflow: hidden;
        transition: max-height var(--transition-slow);
      }
      .properties-panel.open {
        max-height: 240px;
      }
      .properties-inner {
        padding: var(--sp-4);
        display: flex;
        flex-direction: column;
        gap: var(--sp-3);
      }
      .properties-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .properties-title {
        font-size: var(--text-sm);
        font-weight: 700;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--color-text-secondary);
      }
      .properties-id {
        font-family: var(--font-mono);
        font-size: var(--text-xs);
        color: var(--color-text-disabled);
      }
      .property-row {
        display: flex;
        align-items: center;
        gap: var(--sp-3);
      }
      .property-label {
        font-size: var(--text-xs);
        font-weight: 600;
        color: var(--color-text-secondary);
        letter-spacing: 0.04em;
        text-transform: uppercase;
        width: 64px;
        flex-shrink: 0;
      }
      .property-input {
        flex: 1;
        padding: 6px 10px;
        background: var(--color-bg-input);
        border: 1px solid var(--color-border-default);
        border-radius: var(--radius-sm);
        color: var(--color-text-primary);
        font-family: var(--font-mono);
        font-size: var(--text-sm);
        font-weight: 500;
        outline: none;
        transition:
          border-color var(--transition-fast),
          box-shadow var(--transition-fast);
      }
      .property-input:focus {
        border-color: var(--color-accent);
        box-shadow: 0 0 0 3px var(--color-accent-glow-sm);
      }
      .property-unit {
        font-family: var(--font-mono);
        font-size: var(--text-xs);
        font-weight: 500;
        color: var(--color-text-disabled);
        width: 24px;
        flex-shrink: 0;
      }
      .property-actions {
        display: flex;
        gap: var(--sp-2);
      }
      .prop-btn {
        flex: 1;
        padding: 6px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--color-border-default);
        background: transparent;
        color: var(--color-text-secondary);
        font-family: var(--font-ui);
        font-size: var(--text-xs);
        font-weight: 600;
        letter-spacing: 0.04em;
        cursor: pointer;
        transition: all var(--transition-fast);
        text-align: center;
      }
      .prop-btn:hover {
        background: rgba(255, 255, 255, 0.06);
        color: var(--color-text-primary);
      }
      .prop-btn.rotate:hover {
        border-color: var(--color-accent);
        color: var(--color-accent);
      }
      .prop-btn.delete:hover {
        border-color: var(--color-danger);
        color: var(--color-danger);
        background: rgba(239, 68, 68, 0.08);
      }
      #drag-ghost {
        position: fixed;
        pointer-events: none;
        z-index: 999;
        display: none;
        transform: translate(-50%, -50%);
      }
      .shortcuts-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(6px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-base);
      }
      .shortcuts-overlay.open {
        opacity: 1;
        pointer-events: all;
      }
      .shortcuts-card {
        background: var(--color-bg-modal);
        border: 1px solid var(--color-border-strong);
        border-radius: var(--radius-xl);
        padding: var(--sp-8);
        min-width: 360px;
        box-shadow: var(--shadow-lg);
      }
      .shortcuts-heading {
        font-size: 20px;
        font-weight: 800;
        color: var(--color-text-primary);
        margin-bottom: var(--sp-6);
      }
      .shortcut-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--sp-2) 0;
        border-bottom: 1px solid var(--color-border-subtle);
      }
      .shortcut-row:last-child {
        border-bottom: none;
      }
      .shortcut-desc {
        font-size: var(--text-sm);
        color: var(--color-text-secondary);
      }
      .shortcut-keys {
        display: flex;
        gap: 4px;
      }
      .key {
        font-family: var(--font-mono);
        font-size: var(--text-xs);
        font-weight: 600;
        padding: 2px 8px;
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid var(--color-border-default);
        border-bottom: 2px solid var(--color-border-strong);
        border-radius: var(--radius-xs);
        color: var(--color-text-primary);
      }
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.65);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 900;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-base);
      }
      .modal-overlay.open {
        opacity: 1;
        pointer-events: all;
      }
      .modal-card {
        background: var(--color-bg-modal);
        border: 1px solid var(--color-border-strong);
        border-radius: var(--radius-xl);
        padding: var(--sp-8);
        max-width: 360px;
        width: 100%;
        box-shadow: var(--shadow-lg);
        transform: translateY(12px);
        transition: transform var(--transition-base);
      }
      .modal-overlay.open .modal-card {
        transform: translateY(0);
      }
      .modal-icon {
        font-size: 32px;
        margin-bottom: var(--sp-4);
      }
      .modal-title {
        font-size: 24px;
        font-weight: 800;
        color: var(--color-text-primary);
        margin-bottom: var(--sp-2);
      }
      .modal-body {
        font-size: var(--text-sm);
        color: var(--color-text-secondary);
        line-height: 1.6;
        margin-bottom: var(--sp-6);
      }
      .modal-actions {
        display: flex;
        gap: var(--sp-3);
        justify-content: flex-end;
      }
      .modal-btn {
        padding: 8px 20px;
        border-radius: var(--radius-sm);
        font-family: var(--font-ui);
        font-size: var(--text-sm);
        font-weight: 700;
        cursor: pointer;
        transition: all var(--transition-fast);
      }
      .modal-btn.cancel {
        border: 1px solid var(--color-border-default);
        background: transparent;
        color: var(--color-text-secondary);
      }
      .modal-btn.cancel:hover {
        border-color: var(--color-text-secondary);
        color: var(--color-text-primary);
      }
      .modal-btn.confirm {
        border: none;
        background: var(--color-danger);
        color: #fff;
      }
      .modal-btn.confirm:hover {
        background: #dc2626;
        box-shadow: 0 0 16px var(--color-danger-glow);
      }
      .tooltip {
        position: fixed;
        z-index: 500;
        padding: var(--sp-2) var(--sp-3);
        background: var(--color-bg-tooltip);
        border: 1px solid var(--color-border-default);
        border-radius: var(--radius-sm);
        font-family: var(--font-ui);
        font-size: var(--text-xs);
        font-weight: 500;
        color: var(--color-text-primary);
        box-shadow: var(--shadow-md);
        pointer-events: none;
        opacity: 0;
        transform: translateY(4px);
        transition:
          opacity 0.15s,
          transform 0.15s;
        max-width: 220px;
        line-height: 1.5;
      }
      .tooltip.visible {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header class="toolbar">
        <div class="toolbar-brand">
          <div class="toolbar-brand-icon">&#9889;</div>
          <span class="toolbar-brand-name">CircuitSim</span>
          <span class="toolbar-brand-badge">MVP</span>
        </div>
        <div class="toolbar-divider"></div>
        <div class="tool-group">
          <button
            class="tool-btn active"
            data-tool="select"
            title="Select (S)"
            aria-pressed="true"
          >
            <svg viewBox="0 0 16 16">
              <path d="M3 2l10 5.5-5.5 1L5 14 3 2z" /></svg
            >Select
          </button>
          <button
            class="tool-btn"
            data-tool="wire"
            title="Wire (W)"
            aria-pressed="false"
          >
            <svg viewBox="0 0 16 16">
              <path d="M2 8h4M10 8h4M6 8a2 2 0 0 0 4 0 2 2 0 0 0-4 0z" /></svg
            >Wire
          </button>
          <button
            class="tool-btn"
            data-tool="ground"
            title="Ground (G)"
            aria-pressed="false"
          >
            <svg viewBox="0 0 16 16">
              <path d="M8 2v8M4 10h8M5.5 12.5h5M7 15h2" /></svg
            >Ground
          </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="wire-colors">
          <span class="wire-color-label">Wire</span>
          <button
            class="color-swatch active"
            style="background: #60a5fa"
            data-color="#60A5FA"
            title="Blue"
          ></button>
          <button
            class="color-swatch"
            style="background: #34d399"
            data-color="#34D399"
            title="Green"
          ></button>
          <button
            class="color-swatch"
            style="background: #f87171"
            data-color="#F87171"
            title="Red"
          ></button>
          <button
            class="color-swatch"
            style="background: #fbbf24"
            data-color="#FBBF24"
            title="Yellow"
          ></button>
          <button
            class="color-swatch"
            style="background: #e2e8f0"
            data-color="#E2E8F0"
            title="White"
          ></button>
        </div>
        <div class="toolbar-spacer"></div>
        <div class="zoom-group">
          <button class="zoom-btn" id="btn-zoom-out">&#8722;</button>
          <span class="zoom-level" id="zoom-display">100%</span>
          <button class="zoom-btn" id="btn-zoom-in">+</button>
        </div>
        <div class="toolbar-divider"></div>
        <button class="btn-clear" id="btn-clear">
          <svg
            width="13"
            height="13"
            viewBox="0 0 16 16"
            stroke="currentColor"
            fill="none"
            stroke-width="2"
            stroke-linecap="round"
          >
            <path d="M3 3l10 10M13 3L3 13" /></svg
          >Clear
        </button>
        <button class="btn-simulate" id="btn-simulate">
          <svg viewBox="0 0 16 16">
            <polygon points="4,2 14,8 4,14" fill="currentColor" stroke="none" />
          </svg>
          <span id="simulate-label">Simulate</span>
        </button>
      </header>

      <main class="canvas-wrap" id="canvas-wrap" data-mode="select">
        <canvas id="circuit-canvas"></canvas>
        <div class="canvas-status">
          <span class="canvas-status-dot ready" id="status-dot"></span>
          <span id="status-text">Ready</span>
        </div>
        <div class="canvas-coords" id="canvas-coords">x: 0 &nbsp; y: 0</div>
        <div class="toast-container" id="toast-container"></div>
      </main>

      <aside class="panel">
        <div class="panel-header">
          <span class="panel-title">Components</span>
          <span class="panel-component-count" id="canvas-component-count"
            >0 on canvas</span
          >
        </div>
        <div class="panel-body">
          <div class="component-section">
            <div class="component-section-title">Passive</div>
            <div
              class="component-card"
              draggable="true"
              data-type="RESISTOR"
              style="--card-accent: var(--color-comp-resistor)"
              tabindex="0"
              role="button"
              aria-label="Resistor"
            >
              <div class="card-icon">
                <svg
                  viewBox="-22 -10 44 20"
                  stroke="var(--color-comp-resistor)"
                  fill="none"
                  stroke-width="1.8"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <line x1="-20" y1="0" x2="-12" y2="0" />
                  <polyline
                    points="-12,0 -9,-6 -6,6 -3,-6 0,6 3,-6 6,6 9,-6 12,0"
                  />
                  <line x1="12" y1="0" x2="20" y2="0" />
                  <circle
                    cx="-20"
                    cy="0"
                    r="1.5"
                    fill="var(--color-comp-resistor)"
                  />
                  <circle
                    cx="20"
                    cy="0"
                    r="1.5"
                    fill="var(--color-comp-resistor)"
                  />
                </svg>
              </div>
              <div class="card-info">
                <div class="card-name">Resistor</div>
                <div class="card-default">1000 &#937;</div>
              </div>
              <span class="card-handle">&#10815;</span>
            </div>
          </div>
          <div class="component-section">
            <div class="component-section-title">Sources</div>
            <div
              class="component-card"
              draggable="true"
              data-type="VOLTAGE_SOURCE"
              style="--card-accent: var(--color-comp-vsource)"
              tabindex="0"
              role="button"
              aria-label="Voltage Source"
            >
              <div class="card-icon">
                <svg
                  viewBox="-22 -12 44 24"
                  stroke="var(--color-comp-vsource)"
                  fill="none"
                  stroke-width="1.8"
                  stroke-linecap="round"
                >
                  <line x1="-20" y1="0" x2="-10" y2="0" />
                  <circle cx="0" cy="0" r="10" />
                  <line x1="0" y1="-5" x2="0" y2="5" />
                  <line x1="-4" y1="0" x2="4" y2="0" stroke-width="2.5" />
                  <text
                    x="4"
                    y="-2"
                    fill="var(--color-comp-vsource)"
                    stroke="none"
                    font-size="5"
                    font-family="Syne,sans-serif"
                    font-weight="700"
                  >
                    +
                  </text>
                  <line x1="10" y1="0" x2="20" y2="0" />
                  <circle
                    cx="-20"
                    cy="0"
                    r="1.5"
                    fill="var(--color-comp-vsource)"
                  />
                  <circle
                    cx="20"
                    cy="0"
                    r="1.5"
                    fill="var(--color-comp-vsource)"
                  />
                </svg>
              </div>
              <div class="card-info">
                <div class="card-name">Voltage Source</div>
                <div class="card-default">9 V</div>
              </div>
              <span class="card-handle">&#10815;</span>
            </div>
          </div>
          <div class="component-section">
            <div class="component-section-title">Output</div>
            <div
              class="component-card"
              draggable="true"
              data-type="LED"
              style="--card-accent: var(--color-comp-led)"
              tabindex="0"
              role="button"
              aria-label="LED"
            >
              <div class="card-icon">
                <svg
                  viewBox="-22 -12 44 24"
                  stroke="var(--color-comp-led)"
                  fill="none"
                  stroke-width="1.8"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <line x1="-20" y1="0" x2="-8" y2="0" />
                  <polygon
                    points="-8,-8 -8,8 8,0"
                    fill="rgba(34,197,94,0.20)"
                    stroke="var(--color-comp-led)"
                    stroke-width="1.8"
                  />
                  <line x1="8" y1="-8" x2="8" y2="8" />
                  <line x1="8" y1="0" x2="20" y2="0" />
                  <line x1="12" y1="-6" x2="17" y2="-11" stroke-width="1.2" />
                  <line x1="16" y1="-3" x2="21" y2="-8" stroke-width="1.2" />
                  <circle
                    cx="-20"
                    cy="0"
                    r="1.5"
                    fill="var(--color-comp-led)"
                  />
                  <circle cx="20" cy="0" r="1.5" fill="var(--color-comp-led)" />
                </svg>
              </div>
              <div class="card-info">
                <div class="card-name">LED</div>
                <div class="card-default">Vf = 2.0 V</div>
              </div>
              <span class="card-handle">&#10815;</span>
            </div>
            <div
              class="component-card"
              draggable="true"
              data-type="SWITCH"
              style="--card-accent: var(--color-comp-switch)"
              tabindex="0"
              role="button"
              aria-label="Switch"
            >
              <div class="card-icon">
                <svg
                  viewBox="-22 -12 44 24"
                  stroke="var(--color-comp-switch)"
                  fill="none"
                  stroke-width="1.8"
                  stroke-linecap="round"
                >
                  <line x1="-20" y1="0" x2="-8" y2="0" />
                  <circle
                    cx="-8"
                    cy="0"
                    r="1.8"
                    fill="var(--color-comp-switch)"
                  />
                  <line x1="-8" y1="0" x2="8" y2="-8" />
                  <circle
                    cx="8"
                    cy="0"
                    r="1.8"
                    fill="var(--color-comp-switch)"
                  />
                  <line x1="8" y1="0" x2="20" y2="0" />
                  <circle
                    cx="-20"
                    cy="0"
                    r="1.5"
                    fill="var(--color-comp-switch)"
                  />
                  <circle
                    cx="20"
                    cy="0"
                    r="1.5"
                    fill="var(--color-comp-switch)"
                  />
                </svg>
              </div>
              <div class="card-info">
                <div class="card-name">Switch</div>
                <div class="card-default">Normally open</div>
              </div>
              <span class="card-handle">&#10815;</span>
            </div>
          </div>
          <div style="margin-top: auto; padding-top: var(--sp-4)">
            <button
              onclick="
                document
                  .getElementById('shortcuts-overlay')
                  .classList.add('open')
              "
              style="
                width: 100%;
                padding: var(--sp-2);
                background: transparent;
                border: 1px dashed var(--color-border-default);
                border-radius: var(--radius-md);
                color: var(--color-text-disabled);
                font-family: var(--font-ui);
                font-size: var(--text-xs);
                font-weight: 600;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                cursor: pointer;
                transition: all var(--transition-fast);
              "
              onmouseover="
                this.style.borderColor = 'var(--color-border-strong)';
                this.style.color = 'var(--color-text-secondary)';
              "
              onmouseout="
                this.style.borderColor = 'var(--color-border-default)';
                this.style.color = 'var(--color-text-disabled)';
              "
            >
              &#9000; Keyboard Shortcuts
            </button>
          </div>
        </div>
        <div class="properties-panel" id="properties-panel">
          <div class="properties-inner">
            <div class="properties-header">
              <span class="properties-title">Properties</span>
              <span class="properties-id" id="prop-id">&#8212;</span>
            </div>
            <div class="property-row">
              <span class="property-label" id="prop-label">Value</span>
              <input
                class="property-input"
                id="prop-input"
                type="number"
                min="0"
                step="1"
                value="1000"
              />
              <span class="property-unit" id="prop-unit">&#937;</span>
            </div>
            <div class="property-row" id="prop-color-row" style="display: none">
              <span class="property-label">Color</span>
              <div
                id="prop-color-swatches"
                style="display: flex; gap: 6px; flex-wrap: wrap; flex: 1"
              ></div>
              <input
                type="color"
                id="prop-color-custom"
                title="Custom color"
                style="
                  width: 28px;
                  height: 28px;
                  padding: 2px;
                  border-radius: 6px;
                  border: 1px solid var(--color-border-default);
                  background: var(--color-bg-input);
                  cursor: pointer;
                  flex-shrink: 0;
                "
              />
            </div>
            <div class="property-actions">
              <button class="prop-btn rotate" id="prop-rotate">
                &#10227; Rotate
              </button>
              <button class="prop-btn delete" id="prop-delete">
                &#10005; Delete
              </button>
            </div>
          </div>
        </div>
      </aside>
    </div>

    <canvas id="drag-ghost" width="140" height="80"></canvas>

    <div class="shortcuts-overlay" id="shortcuts-overlay">
      <div class="shortcuts-card">
        <div class="shortcuts-heading">Keyboard Shortcuts</div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Select tool</span>
          <div class="shortcut-keys"><span class="key">S</span></div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Wire tool</span>
          <div class="shortcut-keys"><span class="key">W</span></div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Ground tool</span>
          <div class="shortcut-keys"><span class="key">G</span></div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Rotate selected</span>
          <div class="shortcut-keys"><span class="key">R</span></div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Delete selected</span>
          <div class="shortcut-keys"><span class="key">Del</span></div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Toggle switch</span>
          <div class="shortcut-keys"><span class="key">Dbl-click</span></div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Undo</span>
          <div class="shortcut-keys">
            <span class="key">Ctrl</span><span class="key">Z</span>
          </div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Pan canvas</span>
          <div class="shortcut-keys">
            <span class="key">Space</span><span class="key">+Drag</span>
          </div>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-desc">Zoom</span>
          <div class="shortcut-keys"><span class="key">Scroll</span></div>
        </div>
        <div style="margin-top: 20px; text-align: right">
          <button
            onclick="
              document
                .getElementById('shortcuts-overlay')
                .classList.remove('open')
            "
            style="
              padding: 8px 20px;
              background: var(--color-accent);
              border: none;
              border-radius: var(--radius-sm);
              color: #fff;
              font-family: var(--font-ui);
              font-size: var(--text-sm);
              font-weight: 700;
              cursor: pointer;
            "
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <div class="modal-overlay" id="clear-modal">
      <div class="modal-card">
        <div class="modal-icon">&#128465;&#65039;</div>
        <div class="modal-title">Clear Canvas?</div>
        <div class="modal-body">
          This will remove all components and wires. This action cannot be
          undone.
        </div>
        <div class="modal-actions">
          <button class="modal-btn cancel" id="modal-cancel">Cancel</button>
          <button class="modal-btn confirm" id="modal-confirm">
            Clear Everything
          </button>
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
      // ═══════════════════════════════════════════════════════════
      // tsk-102: COMPONENT SYSTEM
      // Adds to tsk-101 (grid/zoom/pan/toolbar):
      //   Module 1  — Canvas & coordinate helpers (carried from tsk-101)
      //   Module 2  — Component data model + factory function
      //   Module 3  — Canvas renderer (all 4 component types)
      //   Module 4  — Panel drag → canvas drop + ghost preview
      //   Module 5  — Hit testing & selection
      //   Module 6  — Move drag (reposition on canvas)
      //   Module 7  — Properties panel (value edit, rotate, delete)
      //   Module 8  — Rotate & Delete actions
      //   Module 9  — Undo system (snapshot, max 30)
      //   Module 10 — Zoom & pan (unchanged from tsk-101)
      //   Module 11 — Toolbar, shortcuts, toast, tooltip
      // ═══════════════════════════════════════════════════════════

      // ── Module 1: Canvas setup ───────────────────────────────
      const canvas = document.getElementById("circuit-canvas");
      const ctx = canvas.getContext("2d");
      const wrap = document.getElementById("canvas-wrap");
      const GRID = 20;
      const ZOOM_MIN = 0.35,
        ZOOM_MAX = 3.0,
        ZOOM_STEP = 0.12;

      const state = {
        pan: { x: 0, y: 0 },
        zoom: 1.0,
        mode: "select",
        wireColor: "#60A5FA",
        mouseGrid: { x: 0, y: 0 },
        components: [],
        wires: [],
        selectedId: null,
        undoStack: [],
        moveDrag: null,
        wireFromTermId: null, // tsk-103: active wire source terminal id
        hoverTermId: null, // tsk-103: terminal under cursor in wire mode
        groundTermId: null, // tsk-104: terminal designated as node 0 (ground)
        netlist: null, // tsk-104: last built netlist (consumed by tsk-105)
        simResult: null, // tsk-105: last simulation result (consumed by tsk-107)
      };

      const css = (v) =>
        getComputedStyle(document.documentElement).getPropertyValue(v).trim();
      const toCanvas = (gx, gy) => ({
        x: gx * GRID * state.zoom + state.pan.x,
        y: gy * GRID * state.zoom + state.pan.y,
      });
      const toGrid = (cx, cy) => ({
        x: Math.round((cx - state.pan.x) / (GRID * state.zoom)),
        y: Math.round((cy - state.pan.y) / (GRID * state.zoom)),
      });

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1,
          w = wrap.clientWidth,
          h = wrap.clientHeight;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";
        ctx.scale(dpr, dpr);
        render();
      }
      new ResizeObserver(resizeCanvas).observe(wrap);

      // ── Module 2: Component data model ───────────────────────
      const _cnt = { RESISTOR: 0, VOLTAGE_SOURCE: 0, LED: 0, SWITCH: 0 };
      const DEFAULTS = {
        RESISTOR: { value: 1000, label: "R" },
        VOLTAGE_SOURCE: { value: 9, label: "V" },
        LED: { value: 2.0, label: "D" },
        SWITCH: { value: 0, label: "SW", closed: false },
      };
      // Default LED colors (user can override per-instance via color picker)
      const LED_COLORS = [
        "#22C55E",
        "#EF4444",
        "#F59E0B",
        "#60A5FA",
        "#A78BFA",
        "#F472B6",
      ];
      const TERM_OFF = {
        RESISTOR: [
          { label: "A", ox: -3, oy: 0 },
          { label: "B", ox: 3, oy: 0 },
        ],
        VOLTAGE_SOURCE: [
          { label: "A", ox: -3, oy: 0 },
          { label: "B", ox: 3, oy: 0 },
        ],
        LED: [
          { label: "A", ox: -3, oy: 0 },
          { label: "B", ox: 3, oy: 0 },
        ],
        SWITCH: [
          { label: "A", ox: -3, oy: 0 },
          { label: "B", ox: 3, oy: 0 },
        ],
      };
      const ID_PREFIX = {
        RESISTOR: "r",
        VOLTAGE_SOURCE: "v",
        LED: "d",
        SWITCH: "sw",
      };

      function createComponent(type, gx, gy) {
        _cnt[type]++;
        const n = _cnt[type];
        const id = ID_PREFIX[type] + n;
        const d = DEFAULTS[type];
        return {
          id,
          type,
          x: gx,
          y: gy,
          rotation: 0,
          value: d.value,
          label: d.label + n,
          closed: d.closed ?? null,
          ledColor: type === "LED" ? "#22C55E" : null,
          terminals: TERM_OFF[type].map((t) => ({
            id: id + "_" + t.label,
            componentId: id,
            label: t.label,
            ox: t.ox,
            oy: t.oy,
            node: null,
          })),
        };
      }

      function termPos(comp, term) {
        const rad = (comp.rotation * Math.PI) / 180;
        return {
          x: comp.x + term.ox * Math.cos(rad) - term.oy * Math.sin(rad),
          y: comp.y + term.ox * Math.sin(rad) + term.oy * Math.cos(rad),
        };
      }

      // ── Module 3: Canvas renderer ─────────────────────────────
      const COMP_COLORS = {
        RESISTOR: "#60A5FA",
        VOLTAGE_SOURCE: "#F59E0B",
        LED: "#22C55E",
        SWITCH: "#94A3B8",
      };

      function drawSelBox(ctx, hw, hh, zoom) {
        const p = 6 * zoom;
        ctx.save();
        ctx.strokeStyle = css("--color-accent");
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 3]);
        ctx.shadowColor = css("--color-accent");
        ctx.shadowBlur = 8;
        ctx.strokeRect(-(hw + p), -(hh + p), (hw + p) * 2, (hh + p) * 2);
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      function drawTermDots(ctx, comp, zoom) {
        // Use per-instance color for LED, global color for others
        const col =
          comp.type === "LED" && comp.ledColor
            ? comp.ledColor
            : COMP_COLORS[comp.type];
        comp.terminals.forEach((t) => {
          // ctx is already translated+rotated to component centre by the caller.
          // Draw at the raw grid-unit offset × pixel scale — NO extra rotation needed.
          const rx = t.ox * GRID * zoom;
          const ry = t.oy * GRID * zoom;

          // glow ring for hovered or active-from terminal
          const isFrom = state.wireFromTermId === t.id;
          const isHover = state.hoverTermId === t.id;
          if (isFrom || isHover) {
            ctx.beginPath();
            ctx.arc(rx, ry, (isFrom ? 9 : 7) * zoom, 0, Math.PI * 2);
            ctx.fillStyle = isFrom
              ? "rgba(79,142,247,0.35)"
              : "rgba(79,142,247,0.20)";
            ctx.fill();
          }

          ctx.beginPath();
          ctx.arc(rx, ry, (isFrom ? 5 : 3.5) * zoom, 0, Math.PI * 2);
          ctx.fillStyle = isFrom ? css("--color-accent") : col;
          ctx.fill();
          ctx.strokeStyle = css("--color-bg-canvas");
          ctx.lineWidth = 1;
          ctx.stroke();
        });
      }

      function fmtVal(comp) {
        if (comp.type === "RESISTOR")
          return comp.value >= 1e6
            ? comp.value / 1e6 + " MΩ"
            : comp.value >= 1e3
              ? comp.value / 1e3 + " kΩ"
              : comp.value + " Ω";
        if (comp.type === "VOLTAGE_SOURCE") return comp.value + " V";
        if (comp.type === "LED") return "Vf " + comp.value + " V";
        if (comp.type === "SWITCH") return comp.closed ? "closed" : "open";
      }

      function drawCompLabel(ctx, comp, zoom) {
        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillStyle = css("--color-text-secondary");
        ctx.font = 10 * zoom + "px Syne,sans-serif";
        ctx.fillText(comp.label, 0, 18 * zoom);
        ctx.fillStyle = css("--color-text-disabled");
        ctx.font = 9 * zoom + "px JetBrains Mono,monospace";
        ctx.fillText(fmtVal(comp), 0, 30 * zoom);
        ctx.restore();
      }

      function drawResistor(ctx, comp, zoom) {
        ctx.save();
        const c = toCanvas(comp.x, comp.y);
        ctx.translate(c.x, c.y);
        ctx.rotate((comp.rotation * Math.PI) / 180);
        if (comp.id === state.selectedId)
          drawSelBox(ctx, 30 * zoom, 10 * zoom, zoom);
        const col = COMP_COLORS.RESISTOR;
        ctx.strokeStyle = col;
        ctx.lineWidth = 2 * zoom;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(-30 * zoom, 0);
        ctx.lineTo(-12 * zoom, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(12 * zoom, 0);
        ctx.lineTo(30 * zoom, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-12 * zoom, 0);
        [-9, -6, -3, 0, 3, 6, 9, 12]
          .map((v) => v * zoom)
          .forEach((x, i) => ctx.lineTo(x, (i % 2 === 0 ? -6 : 6) * zoom));
        ctx.stroke();
        drawTermDots(ctx, comp, zoom);
        drawCompLabel(ctx, comp, zoom);
        ctx.restore();
      }

      function drawVSource(ctx, comp, zoom) {
        ctx.save();
        const c = toCanvas(comp.x, comp.y);
        ctx.translate(c.x, c.y);
        ctx.rotate((comp.rotation * Math.PI) / 180);
        if (comp.id === state.selectedId)
          drawSelBox(ctx, 30 * zoom, 12 * zoom, zoom);
        const col = COMP_COLORS.VOLTAGE_SOURCE;
        ctx.strokeStyle = col;
        ctx.lineWidth = 2 * zoom;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(-30 * zoom, 0);
        ctx.lineTo(-12 * zoom, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(12 * zoom, 0);
        ctx.lineTo(30 * zoom, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, 0, 12 * zoom, 0, Math.PI * 2);
        ctx.fillStyle = css("--color-bg-canvas");
        ctx.fill();
        ctx.strokeStyle = col;
        ctx.stroke();
        ctx.lineWidth = 1.8 * zoom;
        // + (right/B side)
        ctx.beginPath();
        ctx.moveTo(4 * zoom, -3 * zoom);
        ctx.lineTo(4 * zoom, 3 * zoom);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(1 * zoom, 0);
        ctx.lineTo(7 * zoom, 0);
        ctx.stroke();
        // - (left/A side)
        ctx.beginPath();
        ctx.moveTo(-7 * zoom, 0);
        ctx.lineTo(-1 * zoom, 0);
        ctx.stroke();
        drawTermDots(ctx, comp, zoom);
        drawCompLabel(ctx, comp, zoom);
        ctx.restore();
      }

      function drawLED(ctx, comp, zoom, current) {
        current = current || 0;
        ctx.save();
        const c = toCanvas(comp.x, comp.y);
        ctx.translate(c.x, c.y);
        ctx.rotate((comp.rotation * Math.PI) / 180);
        if (comp.id === state.selectedId)
          drawSelBox(ctx, 30 * zoom, 10 * zoom, zoom);

        // Use per-instance color (falls back to default green)
        const col = comp.ledColor || COMP_COLORS.LED;

        // Glow intensity: scales linearly from 10mA (threshold) to 30mA (full)
        const I_MIN = 0.01,
          I_MAX = 0.03;
        const absCurrent = Math.abs(current);
        const lit = absCurrent >= I_MIN;
        const intensity = lit
          ? Math.min(1, (absCurrent - I_MIN) / (I_MAX - I_MIN))
          : 0;

        if (lit) {
          ctx.shadowColor = col;
          ctx.shadowBlur = (12 + intensity * 28) * zoom; // 12→40px
        }

        ctx.strokeStyle = col;
        ctx.lineWidth = 2 * zoom;
        ctx.lineCap = "round";

        // Lead wires
        ctx.beginPath();
        ctx.moveTo(-30 * zoom, 0);
        ctx.lineTo(-8 * zoom, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(8 * zoom, 0);
        ctx.lineTo(30 * zoom, 0);
        ctx.stroke();

        // Triangle body
        ctx.beginPath();
        ctx.moveTo(-8 * zoom, -8 * zoom);
        ctx.lineTo(-8 * zoom, 8 * zoom);
        ctx.lineTo(8 * zoom, 0);
        ctx.closePath();
        // Fill alpha scales with intensity: 0.12 → 0.55
        const fillAlpha = lit ? 0.12 + intensity * 0.43 : 0.1;
        ctx.fillStyle =
          col +
          Math.round(fillAlpha * 255)
            .toString(16)
            .padStart(2, "0");
        ctx.fill();
        ctx.strokeStyle = col;
        ctx.stroke();

        // Cathode bar
        ctx.beginPath();
        ctx.moveTo(8 * zoom, -8 * zoom);
        ctx.lineTo(8 * zoom, 8 * zoom);
        ctx.stroke();

        ctx.shadowBlur = 0;

        // Emission rays (brighter when conducting)
        ctx.lineWidth = (lit ? 1.5 : 1.0) * zoom;
        ctx.globalAlpha = lit ? 0.5 + intensity * 0.5 : 0.4;
        [
          [12, -4, 17, -9],
          [16, -1, 21, -6],
        ].forEach(([x1, y1, x2, y2]) => {
          ctx.beginPath();
          ctx.moveTo(x1 * zoom, y1 * zoom);
          ctx.lineTo(x2 * zoom, y2 * zoom);
          ctx.stroke();
        });
        ctx.globalAlpha = 1;

        drawTermDots(ctx, comp, zoom);
        drawCompLabel(ctx, comp, zoom);
        ctx.restore();
      }

      function drawSwitch(ctx, comp, zoom) {
        ctx.save();
        const c = toCanvas(comp.x, comp.y);
        ctx.translate(c.x, c.y);
        ctx.rotate((comp.rotation * Math.PI) / 180);
        if (comp.id === state.selectedId)
          drawSelBox(ctx, 30 * zoom, 12 * zoom, zoom);
        const col = comp.closed
          ? css("--color-comp-switch-on")
          : COMP_COLORS.SWITCH;
        ctx.strokeStyle = col;
        ctx.lineWidth = 2 * zoom;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(-30 * zoom, 0);
        ctx.lineTo(-10 * zoom, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(10 * zoom, 0);
        ctx.lineTo(30 * zoom, 0);
        ctx.stroke();
        [
          [-10, 0],
          [10, 0],
        ].forEach(([x, y]) => {
          ctx.beginPath();
          ctx.arc(x * zoom, y * zoom, 2.5 * zoom, 0, Math.PI * 2);
          ctx.fillStyle = col;
          ctx.fill();
        });
        ctx.beginPath();
        ctx.moveTo(-10 * zoom, 0);
        ctx.lineTo(10 * zoom, comp.closed ? 0 : -10 * zoom);
        ctx.stroke();
        drawTermDots(ctx, comp, zoom);
        drawCompLabel(ctx, comp, zoom);
        ctx.restore();
      }

      const DRAW_FN = {
        RESISTOR: drawResistor,
        VOLTAGE_SOURCE: drawVSource,
        LED: drawLED,
        SWITCH: drawSwitch,
      };

      function drawGrid() {
        const W = wrap.clientWidth,
          H = wrap.clientHeight;
        const sp = GRID * state.zoom;
        const ox = ((state.pan.x % sp) + sp) % sp,
          oy = ((state.pan.y % sp) + sp) % sp;
        const dr = Math.max(0.8, 1.5 * state.zoom);
        ctx.fillStyle = css("--color-canvas-dot");
        for (let x = ox; x < W; x += sp)
          for (let y = oy; y < H; y += sp) {
            ctx.beginPath();
            ctx.arc(x, y, dr, 0, Math.PI * 2);
            ctx.fill();
          }
      }

      function drawSnapIndicator() {
        if (!panelDrag.active) return;
        const gp = toCanvas(panelDrag.snapX, panelDrag.snapY);
        ctx.save();
        ctx.strokeStyle = "rgba(79,142,247,0.5)";
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        const sz = 10 * state.zoom;
        ctx.beginPath();
        ctx.moveTo(gp.x - sz, gp.y);
        ctx.lineTo(gp.x + sz, gp.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(gp.x, gp.y - sz);
        ctx.lineTo(gp.x, gp.y + sz);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }

      function render() {
        const W = wrap.clientWidth,
          H = wrap.clientHeight;
        ctx.clearRect(0, 0, W, H);
        drawGrid();
        drawSnapIndicator();
        // tsk-103: draw placed wires
        state.wires.forEach((w) => drawWire(ctx, w));
        // tsk-103: junction dots at T-intersections
        drawJunctions(ctx);
        // tsk-103: draw live wire preview
        if (state.wireFromTermId && state.mouseGrid) {
          drawWirePreview(
            ctx,
            state.wireFromTermId,
            state.mouseGrid.x,
            state.mouseGrid.y,
          );
        }
        state.components.forEach((c) => {
          const f = DRAW_FN[c.type];
          if (!f) return;
          // Pass branch current to LED so it glows when conducting
          const current = state.simResult
            ? (state.simResult.branchCurrents.get(c.id) ?? 0)
            : 0;
          f(ctx, c, state.zoom, current);
        });
        // tsk-104: draw ground symbol on the designated terminal
        if (state.groundTermId) drawGroundSymbol(ctx);
        // tsk-107: draw simulation result overlays
        if (state.simResult && state.netlist) drawSimResults(ctx);
      }

      // ── Module 8: Wire Drawing (tsk-103) ─────────────────────

      /** Generate a unique wire id */
      let _wireCnt = 0;
      function nextWireId() {
        return "w" + ++_wireCnt;
      }

      /**
       * Return canvas-pixel position of a terminal.
       * Uses termPos() (grid coords) then toCanvas().
       */
      function termCanvasPos(comp, term) {
        const gp = termPos(comp, term);
        return toCanvas(gp.x, gp.y);
      }

      /**
       * Find the terminal closest to canvas point (cx, cy).
       * Returns { comp, term } or null if none within SNAP_R pixels.
       */
      const TERM_SNAP_R = 14; // px snap radius (canvas pixels)
      function hitTestTerminal(cx, cy) {
        let best = null,
          bestD = TERM_SNAP_R;
        state.components.forEach((comp) => {
          comp.terminals.forEach((term) => {
            const cp = termCanvasPos(comp, term);
            const d = Math.hypot(cp.x - cx, cp.y - cy);
            if (d < bestD) {
              bestD = d;
              best = { comp, term };
            }
          });
        });
        return best;
      }

      /**
       * Compute L-shaped orthogonal waypoints between two grid positions.
       * Returns flat array [x1,y1, x2,y2, ...] in GRID UNITS (not pixels).
       * Stored on wire objects so they stay correct across pan/zoom/move.
       */
      function computeWaypoints(ax, ay, bx, by) {
        const midX = (ax + bx) / 2;
        return [ax, ay, midX, ay, midX, by, bx, by];
      }

      /**
       * When a component moves or rotates, update only the terminal endpoints
       * of attached wires. Intermediate user-placed waypoints are preserved.
       */
      function refreshWiresForComp(comp) {
        state.wires.forEach((w) => {
          const fromComp = state.components.find((c) =>
            c.terminals.some((t) => t.id === w.fromTermId),
          );
          const toComp = state.components.find((c) =>
            c.terminals.some((t) => t.id === w.toTermId),
          );
          if (!fromComp || !toComp) return;
          if (fromComp.id !== comp.id && toComp.id !== comp.id) return;

          const fromTerm = fromComp.terminals.find(
            (t) => t.id === w.fromTermId,
          );
          const toTerm = toComp.terminals.find((t) => t.id === w.toTermId);
          const fgp = termPos(fromComp, fromTerm);
          const tgp = termPos(toComp, toTerm);

          // Update only first and last waypoint pairs; keep middle points intact
          w.waypoints[0] = fgp.x;
          w.waypoints[1] = fgp.y;
          w.waypoints[w.waypoints.length - 2] = tgp.x;
          w.waypoints[w.waypoints.length - 1] = tgp.y;
        });
      }

      /** Draw a placed wire — converts grid-unit waypoints to canvas pixels at draw time. */
      function drawWire(ctx, wire) {
        const gpts = wire.waypoints;
        if (!gpts || gpts.length < 4) return;
        const pts = [];
        for (let i = 0; i < gpts.length; i += 2) {
          const cp = toCanvas(gpts[i], gpts[i + 1]);
          pts.push(cp.x, cp.y);
        }
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = wire.color;
        ctx.lineWidth = 2.5 * state.zoom;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.moveTo(pts[0], pts[1]);
        for (let i = 2; i < pts.length; i += 2) ctx.lineTo(pts[i], pts[i + 1]);
        ctx.stroke();

        // Junction dot at each intermediate user-placed waypoint
        for (let i = 2; i < pts.length - 2; i += 2) {
          ctx.beginPath();
          ctx.arc(pts[i], pts[i + 1], 3.5 * state.zoom, 0, Math.PI * 2);
          ctx.fillStyle = wire.color;
          ctx.fill();
        }
        ctx.restore();
      }

      /**
       * Draw the live "rubber-band" preview while a wire is being drawn.
       * fromTermId → current mouse grid position (gx, gy).
       */
      function drawWirePreview(ctx, fromTermId, gx, gy) {
        if (!activeWire) return;
        const pts = [];
        // Convert all accumulated user points to canvas pixels
        activeWire.points.forEach((p) => {
          const cp = toCanvas(p.x, p.y);
          pts.push(cp.x, cp.y);
        });
        // Add live cursor position
        const cp = toCanvas(gx, gy);
        pts.push(cp.x, cp.y);

        if (pts.length < 4) return;
        ctx.save();
        ctx.beginPath();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = state.wireColor;
        ctx.lineWidth = 2 * state.zoom;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.globalAlpha = 0.75;
        ctx.moveTo(pts[0], pts[1]);
        for (let i = 2; i < pts.length; i += 2) ctx.lineTo(pts[i], pts[i + 1]);
        ctx.stroke();

        // Dot at each placed waypoint (not the first terminal dot, not cursor)
        activeWire.points.slice(1).forEach((p) => {
          const wp = toCanvas(p.x, p.y);
          ctx.beginPath();
          ctx.arc(wp.x, wp.y, 4 * state.zoom, 0, Math.PI * 2);
          ctx.fillStyle = state.wireColor;
          ctx.fill();
        });
        ctx.restore();
      }

      // ── Junction detection & rendering ───────────────────────

      /**
       * Check if grid point (px, py) lies exactly on a wire segment
       * (not at its endpoints — those are terminals, not junctions).
       * Segments are axis-aligned so we use integer comparisons.
       */
      function pointOnSegment(px, py, x1, y1, x2, y2) {
        const EPS = 0.01;
        if (Math.abs(y1 - y2) < EPS) {
          // horizontal segment
          if (Math.abs(py - y1) > EPS) return false;
          return px > Math.min(x1, x2) + EPS && px < Math.max(x1, x2) - EPS;
        }
        if (Math.abs(x1 - x2) < EPS) {
          // vertical segment
          if (Math.abs(px - x1) > EPS) return false;
          return py > Math.min(y1, y2) + EPS && py < Math.max(y1, y2) - EPS;
        }
        return false;
      }

      /**
       * Collect all T-intersection junction points.
       * A junction dot is drawn wherever ANY wire's waypoint (including terminal
       * endpoints) lies on the interior of another wire's segment.
       * Returns array of {x, y} in grid units (de-duplicated).
       */
      function collectJunctions() {
        const junctions = new Map();

        function segments(wire) {
          const p = wire.waypoints;
          const segs = [];
          for (let i = 0; i < p.length - 2; i += 2)
            segs.push({ x1: p[i], y1: p[i + 1], x2: p[i + 2], y2: p[i + 3] });
          return segs;
        }

        // Every waypoint on every wire (all grid-unit points)
        const allPoints = [];
        state.wires.forEach((w) => {
          for (let i = 0; i < w.waypoints.length; i += 2)
            allPoints.push({ x: w.waypoints[i], y: w.waypoints[i + 1] });
        });

        // Check each point against all segments from all wires
        allPoints.forEach((pt) => {
          state.wires.forEach((w) => {
            segments(w).forEach((seg) => {
              if (pointOnSegment(pt.x, pt.y, seg.x1, seg.y1, seg.x2, seg.y2)) {
                const key = pt.x.toFixed(3) + "," + pt.y.toFixed(3);
                junctions.set(key, { x: pt.x, y: pt.y });
              }
            });
          });
        });

        return Array.from(junctions.values());
      }

      /** Draw filled junction dots at all T-intersection points. */
      function drawJunctions(ctx) {
        const jpts = collectJunctions();
        if (jpts.length === 0) return;
        ctx.save();
        jpts.forEach(({ x, y }) => {
          const cp = toCanvas(x, y);
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, 5 * state.zoom, 0, Math.PI * 2);
          ctx.fillStyle = "#60A5FA";
          ctx.shadowColor = "rgba(79,142,247,0.6)";
          ctx.shadowBlur = 6 * state.zoom;
          ctx.fill();
          ctx.shadowBlur = 0;
        });
        ctx.restore();
      }

      // ── Wire mode: canvas click handling ─────────────────────

      // ── Wire mode: canvas click handling ─────────────────────
      // activeWire tracks the wire currently being drawn (multi-segment)
      // { fromTermId, points: [{x,y},...] }  — points in grid units
      let activeWire = null;

      canvas.addEventListener("mousedown", (e) => {
        if (e.button !== 0 || state.mode !== "wire") return;
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const termHit = hitTestTerminal(cx, cy);
        const gp = toGrid(cx, cy); // snapped grid point under cursor

        if (!activeWire) {
          // ── Phase 1: start wire from a terminal ──────────────
          if (!termHit) return; // must start on a terminal
          const startGp = termPos(termHit.comp, termHit.term);
          activeWire = {
            fromTermId: termHit.term.id,
            fromComp: termHit.comp,
            fromTerm: termHit.term,
            points: [{ x: startGp.x, y: startGp.y }],
          };
          state.wireFromTermId = termHit.term.id;
          render();
        } else {
          // ── Phase 2+: extend or finish wire ──────────────────
          if (termHit) {
            // Clicked a terminal → finish the wire
            const from = activeWire;
            const toComp = termHit.comp;
            const toTerm = termHit.term;

            // Guards
            if (toTerm.id === from.fromTermId) return;
            if (toComp.id === from.fromComp.id) {
              showToast(
                "Can't connect a component to itself.",
                "warning",
                2000,
              );
              return;
            }
            const alreadyWired = state.wires.some(
              (w) =>
                (w.fromTermId === from.fromTermId &&
                  w.toTermId === toTerm.id) ||
                (w.fromTermId === toTerm.id && w.toTermId === from.fromTermId),
            );
            if (alreadyWired) {
              showToast(
                "Those terminals are already connected.",
                "warning",
                2000,
              );
              return;
            }

            // Build final waypoints: existing user points + destination terminal pos
            const endGp = termPos(toComp, toTerm);
            const allPoints = [...from.points, { x: endGp.x, y: endGp.y }];
            const waypoints = allPoints.flatMap((p) => [p.x, p.y]);

            pushUndo();
            state.wires.push({
              id: nextWireId(),
              fromTermId: from.fromTermId,
              toTermId: toTerm.id,
              color: state.wireColor,
              waypoints, // grid units, user-controlled path
              node: null,
            });
            // Reset
            activeWire = null;
            state.wireFromTermId = null;
            state.hoverTermId = null;
            render();
            showToast("Wire connected.", "success", 1200);
          } else {
            // Clicked empty canvas → place an intermediate waypoint (junction/bend)
            const last = activeWire.points[activeWire.points.length - 1];
            // Only add if it's a new position
            if (
              Math.abs(gp.x - last.x) > 0.1 ||
              Math.abs(gp.y - last.y) > 0.1
            ) {
              activeWire.points.push({ x: gp.x, y: gp.y });
              render();
            }
          }
        }
      });

      // Wire mode: hover → update hoverTermId + preview
      canvas.addEventListener("mousemove", (e) => {
        if (state.mode !== "wire") return;
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const hit = hitTestTerminal(cx, cy);
        const newHover = hit ? hit.term.id : null;
        if (newHover !== state.hoverTermId) {
          state.hoverTermId = newHover;
          render();
        }
      });

      // ── Module 4: Panel drag → canvas drop ───────────────────
      const panelDrag = { active: false, type: null, snapX: 0, snapY: 0 };
      const ghost = document.getElementById("drag-ghost");
      const ghostCtx = ghost.getContext("2d");

      function drawGhostComp(type) {
        ghostCtx.clearRect(0, 0, ghost.width, ghost.height);
        ghostCtx.save();
        ghostCtx.translate(ghost.width / 2, ghost.height / 2);
        ghostCtx.globalAlpha = 0.75;
        const col = COMP_COLORS[type];
        ghostCtx.strokeStyle = col;
        ghostCtx.lineWidth = 2;
        ghostCtx.lineCap = "round";
        ghostCtx.lineJoin = "round";
        if (type === "RESISTOR") {
          ghostCtx.beginPath();
          ghostCtx.moveTo(-30, 0);
          ghostCtx.lineTo(-12, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(12, 0);
          ghostCtx.lineTo(30, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(-12, 0);
          [-9, -6, -3, 0, 3, 6, 9, 12].forEach((x, i) =>
            ghostCtx.lineTo(x, i % 2 === 0 ? -6 : 6),
          );
          ghostCtx.stroke();
        } else if (type === "VOLTAGE_SOURCE") {
          ghostCtx.beginPath();
          ghostCtx.moveTo(-30, 0);
          ghostCtx.lineTo(-12, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(12, 0);
          ghostCtx.lineTo(30, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.arc(0, 0, 12, 0, Math.PI * 2);
          ghostCtx.fillStyle = "rgba(10,14,26,0.8)";
          ghostCtx.fill();
          ghostCtx.strokeStyle = col;
          ghostCtx.stroke();
        } else if (type === "LED") {
          ghostCtx.beginPath();
          ghostCtx.moveTo(-30, 0);
          ghostCtx.lineTo(-8, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(8, 0);
          ghostCtx.lineTo(30, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(-8, -8);
          ghostCtx.lineTo(-8, 8);
          ghostCtx.lineTo(8, 0);
          ghostCtx.closePath();
          ghostCtx.fillStyle = "rgba(34,197,94,0.20)";
          ghostCtx.fill();
          ghostCtx.strokeStyle = col;
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(8, -8);
          ghostCtx.lineTo(8, 8);
          ghostCtx.stroke();
        } else if (type === "SWITCH") {
          ghostCtx.beginPath();
          ghostCtx.moveTo(-30, 0);
          ghostCtx.lineTo(-10, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(10, 0);
          ghostCtx.lineTo(30, 0);
          ghostCtx.stroke();
          ghostCtx.beginPath();
          ghostCtx.moveTo(-10, 0);
          ghostCtx.lineTo(10, -10);
          ghostCtx.stroke();
        }
        ghostCtx.restore();
      }

      document.querySelectorAll(".component-card").forEach((card) => {
        card.addEventListener("mousedown", (e) => {
          if (e.button !== 0) return;
          e.preventDefault();
          panelDrag.active = true;
          panelDrag.type = card.dataset.type;
          ghost.style.display = "block";
          drawGhostComp(card.dataset.type);
          ghost.style.left = e.clientX + "px";
          ghost.style.top = e.clientY + "px";
        });
      });

      window.addEventListener("mousemove", (e) => {
        if (!panelDrag.active) return;
        ghost.style.left = e.clientX + "px";
        ghost.style.top = e.clientY + "px";
        const rect = canvas.getBoundingClientRect();
        if (
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom
        ) {
          const gp = toGrid(e.clientX - rect.left, e.clientY - rect.top);
          panelDrag.snapX = gp.x;
          panelDrag.snapY = gp.y;
          render();
        }
      });

      window.addEventListener("mouseup", (e) => {
        if (!panelDrag.active) return;
        ghost.style.display = "none";
        const rect = canvas.getBoundingClientRect();
        const over =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (over) {
          pushUndo();
          const comp = createComponent(
            panelDrag.type,
            panelDrag.snapX,
            panelDrag.snapY,
          );
          state.components.push(comp);
          selectComponent(comp.id);
          updateCount();
          render();
          showToast(
            comp.label + " placed at (" + comp.x + ", " + comp.y + ")",
            "success",
            2000,
          );
        }
        panelDrag.active = false;
        panelDrag.type = null;
        render();
      });

      // ── Module 5: Hit testing & selection ────────────────────
      const HIT = {
        RESISTOR: { hw: 3, hh: 0.8 },
        VOLTAGE_SOURCE: { hw: 3, hh: 1 },
        LED: { hw: 3, hh: 0.8 },
        SWITCH: { hw: 3, hh: 0.8 },
      };

      function hitTest(comp, cx, cy) {
        const centre = toCanvas(comp.x, comp.y);
        const dx = cx - centre.x,
          dy = cy - centre.y;
        const a = -((comp.rotation * Math.PI) / 180);
        const lx = dx * Math.cos(a) - dy * Math.sin(a),
          ly = dx * Math.sin(a) + dy * Math.cos(a);
        const b = HIT[comp.type] ?? { hw: 3, hh: 1 },
          m = 8 * state.zoom;
        return (
          Math.abs(lx) < b.hw * GRID * state.zoom + m &&
          Math.abs(ly) < b.hh * GRID * state.zoom + m
        );
      }

      function selectComponent(id) {
        state.selectedId = id;
        const comp = state.components.find((c) => c.id === id);
        if (comp) openProps(comp);
        else closeProps();
        render();
      }
      function deselectAll() {
        state.selectedId = null;
        closeProps();
        render();
      }

      canvas.addEventListener("mousedown", (e) => {
        if (e.button !== 0 || state.mode !== "select" || panelDrag.active)
          return;
        const rect = canvas.getBoundingClientRect(),
          cx = e.clientX - rect.left,
          cy = e.clientY - rect.top;
        const hit = [...state.components]
          .reverse()
          .find((c) => hitTest(c, cx, cy));
        if (hit) {
          selectComponent(hit.id);
          state.moveDrag = {
            id: hit.id,
            startX: hit.x,
            startY: hit.y,
            mx: e.clientX,
            my: e.clientY,
            moved: false,
          };
        } else {
          deselectAll();
          state.moveDrag = null;
        }
      });

      // ── Module 6: Move drag ───────────────────────────────────
      window.addEventListener("mousemove", (e) => {
        if (!state.moveDrag || panelDrag.active) return;
        const dx = e.clientX - state.moveDrag.mx,
          dy = e.clientY - state.moveDrag.my;
        if (Math.sqrt(dx * dx + dy * dy) < 4) return;
        state.moveDrag.moved = true;
        const comp = state.components.find((c) => c.id === state.moveDrag.id);
        if (!comp) return;
        comp.x = state.moveDrag.startX + Math.round(dx / (GRID * state.zoom));
        comp.y = state.moveDrag.startY + Math.round(dy / (GRID * state.zoom));
        refreshWiresForComp(comp); // tsk-103 fix: recompute attached wire waypoints
        render();
      });
      window.addEventListener("mouseup", (e) => {
        if (state.moveDrag && state.moveDrag.moved) pushUndo();
        state.moveDrag = null;
      });

      // Toggle switch on double-click
      canvas.addEventListener("dblclick", (e) => {
        if (state.mode !== "select") return;
        const rect = canvas.getBoundingClientRect(),
          cx = e.clientX - rect.left,
          cy = e.clientY - rect.top;
        const hit = [...state.components]
          .reverse()
          .find((c) => c.type === "SWITCH" && hitTest(c, cx, cy));
        if (hit) {
          pushUndo();
          hit.closed = !hit.closed;
          render();
          updateProps();
          showToast(
            hit.label + " " + (hit.closed ? "closed" : "opened"),
            "info",
            1500,
          );
        }
      });

      // ── Module 7: Properties panel ────────────────────────────
      const propPanel = document.getElementById("properties-panel");
      const propId = document.getElementById("prop-id");
      const propLabel = document.getElementById("prop-label");
      const propInput = document.getElementById("prop-input");
      const propUnit = document.getElementById("prop-unit");
      const propColorRow = document.getElementById("prop-color-row");
      const propColorSwatches = document.getElementById("prop-color-swatches");
      const propColorCustom = document.getElementById("prop-color-custom");
      const UNIT_MAP = {
        RESISTOR: { l: "Value", u: "Ω" },
        VOLTAGE_SOURCE: { l: "Voltage", u: "V" },
        LED: { l: "Vf", u: "V" },
        SWITCH: { l: "State", u: "" },
      };

      function buildColorSwatches(comp) {
        propColorSwatches.innerHTML = "";
        LED_COLORS.forEach((hex) => {
          const sw = document.createElement("button");
          const active =
            (comp.ledColor || "#22C55E").toLowerCase() === hex.toLowerCase();
          sw.style.cssText = [
            "width:20px",
            "height:20px",
            "border-radius:50%",
            `background:${hex}`,
            `border:2px solid ${active ? "#fff" : "transparent"}`,
            "cursor:pointer",
            "flex-shrink:0",
            `box-shadow:0 0 0 1px ${hex}55`,
            "transition:border 0.15s",
          ].join(";");
          sw.addEventListener("click", () => {
            pushUndo();
            comp.ledColor = hex;
            propColorCustom.value = hex;
            buildColorSwatches(comp);
            render();
          });
          propColorSwatches.appendChild(sw);
        });
        propColorCustom.value = comp.ledColor || "#22C55E";
      }

      function openProps(comp) {
        const m = UNIT_MAP[comp.type] ?? { l: "Value", u: "" };
        propId.textContent = comp.id;
        propLabel.textContent = m.l;
        propUnit.textContent = m.u;
        if (comp.type === "SWITCH") {
          propInput.type = "text";
          propInput.value = comp.closed ? "closed" : "open";
          propInput.readOnly = true;
        } else {
          propInput.type = "number";
          propInput.readOnly = false;
          propInput.value = comp.value;
          propInput.min = comp.type === "RESISTOR" ? "0.001" : "0";
          propInput.step = "0.1";
        }
        // Color picker: only for LEDs
        if (comp.type === "LED") {
          propColorRow.style.display = "flex";
          buildColorSwatches(comp);
        } else {
          propColorRow.style.display = "none";
        }
        propPanel.classList.add("open");
      }
      function closeProps() {
        propPanel.classList.remove("open");
        propId.textContent = "—";
      }
      function updateProps() {
        if (state.selectedId) {
          const c = state.components.find((c) => c.id === state.selectedId);
          if (c) openProps(c);
        }
      }

      // Custom color input (native color picker)
      propColorCustom.addEventListener("input", () => {
        if (!state.selectedId) return;
        const comp = state.components.find((c) => c.id === state.selectedId);
        if (!comp || comp.type !== "LED") return;
        comp.ledColor = propColorCustom.value;
        buildColorSwatches(comp);
        render();
      });
      propColorCustom.addEventListener("change", pushUndo);

      propInput.addEventListener("input", () => {
        if (!state.selectedId) return;
        const comp = state.components.find((c) => c.id === state.selectedId);
        if (!comp || comp.type === "SWITCH") return;
        const v = parseFloat(propInput.value);
        if (!isNaN(v) && v > 0) {
          comp.value = v;
          render();
        }
      });
      propInput.addEventListener("change", pushUndo);
      document
        .getElementById("prop-rotate")
        .addEventListener("click", rotateSelected);
      document
        .getElementById("prop-delete")
        .addEventListener("click", deleteSelected);

      // ── Module 8: Rotate & Delete ─────────────────────────────
      function rotateSelected() {
        if (!state.selectedId) return;
        const comp = state.components.find((c) => c.id === state.selectedId);
        if (!comp) return;
        pushUndo();
        comp.rotation = (comp.rotation + 90) % 360;
        refreshWiresForComp(comp); // recompute attached wire waypoints after rotation
        render();
        updateProps();
      }
      function deleteSelected() {
        if (!state.selectedId) return;
        const i = state.components.findIndex((c) => c.id === state.selectedId);
        if (i === -1) return;
        pushUndo();
        const comp = state.components[i];
        state.wires = state.wires.filter(
          (w) =>
            !comp.terminals.some(
              (t) => t.id === w.fromTermId || t.id === w.toTermId,
            ),
        );
        state.components.splice(i, 1);
        deselectAll();
        updateCount();
        render();
        showToast(comp.label + " deleted.", "info", 1500);
      }

      // ── Module 9: Undo ────────────────────────────────────────
      function pushUndo() {
        state.undoStack.push({
          components: JSON.parse(JSON.stringify(state.components)),
          wires: JSON.parse(JSON.stringify(state.wires)),
          groundTermId: state.groundTermId,
        });
        if (state.undoStack.length > 30) state.undoStack.shift();
      }
      function undo() {
        const snap = state.undoStack.pop();
        if (!snap) {
          showToast("Nothing to undo.", "warning", 1500);
          return;
        }
        state.components = snap.components;
        state.wires = snap.wires;
        state.groundTermId = snap.groundTermId ?? null;
        state.netlist = null;
        state.simResult = null;
        state.selectedId = null;
        closeProps();
        updateCount();
        render();
        showToast("Undo.", "info", 1200);
      }

      function updateCount() {
        const n = state.components.length;
        document.getElementById("canvas-component-count").textContent =
          n === 0 ? "0 on canvas" : n === 1 ? "1 component" : n + " components";
      }

      // ── Module 10: Zoom & Pan ─────────────────────────────────
      function setZoom(nz, fx, fy) {
        nz = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, nz));
        if (nz === state.zoom) return;
        const cx = fx ?? wrap.clientWidth / 2,
          cy = fy ?? wrap.clientHeight / 2,
          r = nz / state.zoom;
        state.pan.x = cx - (cx - state.pan.x) * r;
        state.pan.y = cy - (cy - state.pan.y) * r;
        state.zoom = nz;
        document.getElementById("zoom-display").textContent =
          Math.round(nz * 100) + "%";
        render();
      }
      document
        .getElementById("btn-zoom-in")
        .addEventListener("click", () => setZoom(state.zoom + ZOOM_STEP));
      document
        .getElementById("btn-zoom-out")
        .addEventListener("click", () => setZoom(state.zoom - ZOOM_STEP));
      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const r = canvas.getBoundingClientRect();
          setZoom(
            state.zoom + (e.deltaY < 0 ? ZOOM_STEP : -ZOOM_STEP),
            e.clientX - r.left,
            e.clientY - r.top,
          );
        },
        { passive: false },
      );

      let panStart = null,
        spaceHeld = false;
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && !e.repeat && e.target.tagName !== "INPUT") {
          spaceHeld = true;
          if (state.mode === "select") setMode("pan");
          e.preventDefault();
        }
      });
      document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          spaceHeld = false;
          if (state.mode === "pan") setMode("select");
        }
      });
      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 1 || (e.button === 0 && spaceHeld)) {
          panStart = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
          e.preventDefault();
        }
      });
      window.addEventListener("mousemove", (e) => {
        if (panStart) {
          state.pan.x = e.clientX - panStart.x;
          state.pan.y = e.clientY - panStart.y;
          render();
        }
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 1 || e.button === 0) panStart = null;
      });

      // ── Module 11: Toolbar, shortcuts, toast, tooltip ─────────
      function setMode(m) {
        // cancel any in-progress wire when leaving wire mode
        if (state.mode === "wire" && m !== "wire") {
          activeWire = null;
          state.wireFromTermId = null;
          state.hoverTermId = null;
        }
        state.mode = m;
        wrap.setAttribute("data-mode", m === "pan" ? "pan" : m);
        document.querySelectorAll(".tool-btn").forEach((b) => {
          b.classList.toggle("active", b.dataset.tool === m);
          b.setAttribute("aria-pressed", b.dataset.tool === m);
        });
        setStatus(
          m === "wire" || m === "ground" ? "active" : "ready",
          m === "wire"
            ? "Wire mode — click a terminal to start"
            : m === "ground"
              ? "Click a node to set as ground"
              : m === "pan"
                ? "Panning…"
                : "Ready",
        );
      }
      document
        .querySelectorAll(".tool-btn")
        .forEach((b) =>
          b.addEventListener("click", () => setMode(b.dataset.tool)),
        );
      document.querySelectorAll(".color-swatch").forEach((s) =>
        s.addEventListener("click", () => {
          document
            .querySelectorAll(".color-swatch")
            .forEach((x) => x.classList.remove("active"));
          s.classList.add("active");
          state.wireColor = s.dataset.color;
        }),
      );

      function setStatus(type, text) {
        document.getElementById("status-dot").className =
          "canvas-status-dot " + type;
        document.getElementById("status-text").textContent = text;
      }
      const coordsEl = document.getElementById("canvas-coords");
      canvas.addEventListener("mousemove", (e) => {
        const r = canvas.getBoundingClientRect(),
          gp = toGrid(e.clientX - r.left, e.clientY - r.top);
        state.mouseGrid = gp;
        coordsEl.textContent = "x: " + gp.x + "  y: " + gp.y;
        // tsk-103: redraw preview line while wire is being drawn
        if (state.wireFromTermId) render();
      });

      document.addEventListener("keydown", (e) => {
        if (e.target.tagName === "INPUT") return;
        switch (e.key.toLowerCase()) {
          case "s":
            if (!e.ctrlKey) setMode("select");
            break;
          case "w":
            if (!e.ctrlKey) setMode("wire");
            break;
          case "g":
            if (!e.ctrlKey) setMode("ground");
            break;
          case "r":
            rotateSelected();
            break;
          case "delete":
          case "backspace":
            deleteSelected();
            break;
          case "?":
            document
              .getElementById("shortcuts-overlay")
              .classList.toggle("open");
            break;
          case "escape":
            document
              .getElementById("shortcuts-overlay")
              .classList.remove("open");
            document.getElementById("clear-modal").classList.remove("open");
            if (activeWire || state.wireFromTermId) {
              activeWire = null;
              state.wireFromTermId = null;
              state.hoverTermId = null;
              render();
            }
            if (state.mode !== "select") setMode("select");
            if (state.selectedId) deselectAll();
            break;
        }
        if (e.ctrlKey && e.key === "z") {
          e.preventDefault();
          undo();
        }
      });

      document
        .getElementById("shortcuts-overlay")
        .addEventListener("click", function (e) {
          if (e.target === this) this.classList.remove("open");
        });

      document
        .getElementById("btn-clear")
        .addEventListener("click", () =>
          document.getElementById("clear-modal").classList.add("open"),
        );
      document
        .getElementById("modal-cancel")
        .addEventListener("click", () =>
          document.getElementById("clear-modal").classList.remove("open"),
        );
      document
        .getElementById("clear-modal")
        .addEventListener("click", function (e) {
          if (e.target === this) this.classList.remove("open");
        });
      document.getElementById("modal-confirm").addEventListener("click", () => {
        document.getElementById("clear-modal").classList.remove("open");
        pushUndo();
        Object.keys(_cnt).forEach((k) => (_cnt[k] = 0));
        state.components = [];
        state.wires = [];
        state.selectedId = null;
        state.groundTermId = null;
        state.netlist = null;
        state.simResult = null;
        closeProps();
        updateCount();
        render();
        showToast("Canvas cleared.", "info");
      });

      // ── Module 12: Node Assignment & Netlist Builder (tsk-104) ─

      /**
       * Union-Find with path compression and union by rank.
       * O(α·n) per operation — effectively O(1).
       */
      class UnionFind {
        constructor(n) {
          this.parent = Array.from({ length: n }, (_, i) => i);
          this.rank = new Array(n).fill(0);
        }
        find(x) {
          if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
          return this.parent[x];
        }
        union(a, b) {
          a = this.find(a);
          b = this.find(b);
          if (a === b) return;
          if (this.rank[a] < this.rank[b]) [a, b] = [b, a];
          this.parent[b] = a;
          if (this.rank[a] === this.rank[b]) this.rank[a]++;
        }
        connected(a, b) {
          return this.find(a) === this.find(b);
        }
      }

      /**
       * Build a Netlist from current state.components + state.wires.
       * Assigns node numbers to every terminal via Union-Find.
       * The ground terminal (state.groundTermId) is forced to node 0.
       * Returns { nodeCount, groundNode:0, components } or throws on error.
       */
      function buildNetlist() {
        const components = state.components;
        const wires = state.wires;

        if (components.length === 0)
          throw new Error("No components on canvas.");
        if (wires.length === 0)
          throw new Error("No wires drawn. Connect your components.");

        // ── 1. Index every terminal ──────────────────────────────
        const allTerminals = components.flatMap((c) => c.terminals);
        const termIndex = new Map(allTerminals.map((t, i) => [t.id, i]));
        const uf = new UnionFind(allTerminals.length);

        // ── 2. Union connected terminals via wires ───────────────
        wires.forEach((w) => {
          const a = termIndex.get(w.fromTermId);
          const b = termIndex.get(w.toTermId);
          if (a !== undefined && b !== undefined) uf.union(a, b);
        });

        // ── 3. Assign node numbers ───────────────────────────────
        // Ground terminal gets node 0 first (if designated)
        const rootToNode = new Map();
        let nodeCounter = 1; // 0 reserved for ground

        if (state.groundTermId) {
          const gi = termIndex.get(state.groundTermId);
          if (gi !== undefined) {
            rootToNode.set(uf.find(gi), 0);
          }
        }

        allTerminals.forEach((t) => {
          const root = uf.find(termIndex.get(t.id));
          if (!rootToNode.has(root)) rootToNode.set(root, nodeCounter++);
          t.node = rootToNode.get(root);
        });

        // Also stamp node on wires (for tsk-105 netlist completeness)
        wires.forEach((w) => {
          const ft = allTerminals.find((t) => t.id === w.fromTermId);
          w.node = ft ? ft.node : null;
        });

        const nodeCount = nodeCounter; // includes node 0

        // ── 4. Build NetlistComponent array ─────────────────────
        const netlistComponents = components.map((comp) => {
          const tA = comp.terminals.find((t) => t.label === "A");
          const tB = comp.terminals.find((t) => t.label === "B");
          return {
            id: comp.id,
            type: comp.type,
            nodeA: tA ? tA.node : null,
            nodeB: tB ? tB.node : null,
            value: comp.value,
            closed: comp.closed,
          };
        });

        return {
          nodeCount,
          groundNode: 0,
          components: netlistComponents,
        };
      }

      /**
       * Validate the netlist before handing off to the MNA solver.
       * Returns array of error strings (empty = valid).
       */
      function validateNetlist(netlist) {
        const errors = [];

        // Must have a ground node
        const hasGround = netlist.components.some(
          (c) => c.nodeA === 0 || c.nodeB === 0,
        );
        if (!hasGround)
          errors.push("No ground node. Use the Ground tool (G) to set one.");

        // Must have at least one voltage source
        const hasVSource = netlist.components.some(
          (c) => c.type === "VOLTAGE_SOURCE",
        );
        if (!hasVSource)
          errors.push(
            "No voltage source. Add at least one to drive the circuit.",
          );

        // Check for floating terminals (unconnected = node null)
        const floating = state.components.flatMap((c) =>
          c.terminals
            .filter((t) => t.node === null)
            .map((t) => `${c.label} terminal ${t.label}`),
        );
        if (floating.length > 0)
          errors.push("Unconnected terminal(s): " + floating.join(", ") + ".");

        // Check for short circuit: VS with both terminals on the same node
        netlist.components
          .filter((c) => c.type === "VOLTAGE_SOURCE")
          .forEach((c) => {
            if (c.nodeA !== null && c.nodeA === c.nodeB) {
              const comp = state.components.find((sc) => sc.id === c.id);
              errors.push(
                `Short circuit: ${comp?.label ?? c.id} terminals are on the same node.`,
              );
            }
          });

        // Check for zero/negative resistor values
        netlist.components
          .filter((c) => c.type === "RESISTOR")
          .forEach((c) => {
            if (c.value <= 0) {
              const comp = state.components.find((sc) => sc.id === c.id);
              errors.push(`${comp?.label ?? c.id} resistance must be > 0 Ω.`);
            }
          });

        // Check for zero/negative voltage source values
        netlist.components
          .filter((c) => c.type === "VOLTAGE_SOURCE")
          .forEach((c) => {
            if (c.value <= 0) {
              const comp = state.components.find((sc) => sc.id === c.id);
              errors.push(`${comp?.label ?? c.id} voltage must be > 0 V.`);
            }
          });

        return errors;
      }

      // ── Ground tool: draw ⏚ symbol on designated terminal ──────

      function drawGroundSymbol(ctx) {
        // Find the ground terminal's canvas position
        let gPos = null;
        for (const comp of state.components) {
          const t = comp.terminals.find((t) => t.id === state.groundTermId);
          if (t) {
            gPos = termCanvasPos(comp, t);
            break;
          }
        }
        if (!gPos) return;

        ctx.save();
        ctx.translate(gPos.x, gPos.y);
        ctx.strokeStyle = "#475569";
        ctx.lineWidth = 2 * state.zoom;
        ctx.lineCap = "round";

        // Short stem down from terminal
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 8 * state.zoom);
        ctx.stroke();

        // Three horizontal bars: 12, 8, 4 px wide, 4px apart
        [12, 8, 4].forEach((w, i) => {
          const y = (8 + i * 5) * state.zoom;
          const hw = (w / 2) * state.zoom;
          ctx.beginPath();
          ctx.moveTo(-hw, y);
          ctx.lineTo(hw, y);
          ctx.stroke();
        });
        ctx.restore();
      }

      // ── Ground mode: click canvas to set ground terminal ───────

      canvas.addEventListener("mousedown", (e) => {
        if (e.button !== 0 || state.mode !== "ground") return;
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const hit = hitTestTerminal(cx, cy);
        if (!hit) {
          showToast("Click a terminal dot to set it as ground.", "info", 2000);
          return;
        }
        state.groundTermId = hit.term.id;
        render();
        showToast(
          `${hit.comp.label} terminal ${hit.term.label} set as ground (node 0).`,
          "success",
          2000,
        );
        setMode("select");
      });

      // ── Module 14: Result Rendering (tsk-107) ────────────────

      /** Format a voltage value for display: "10.0 V", "-3.33 V" */
      function fmtV(v) {
        const abs = Math.abs(v);
        if (abs >= 100) return v.toFixed(1) + " V";
        if (abs >= 10) return v.toFixed(2) + " V";
        return v.toFixed(3) + " V";
      }

      /** Format a current value for display: "10.0 mA", "1.23 A" */
      function fmtI(amps) {
        const abs = Math.abs(amps);
        if (abs === 0) return "0 mA";
        if (abs >= 1) return amps.toFixed(3) + " A";
        const mA = amps * 1000;
        if (Math.abs(mA) >= 100) return mA.toFixed(1) + " mA";
        if (Math.abs(mA) >= 10) return mA.toFixed(2) + " mA";
        return mA.toFixed(3) + " mA";
      }

      /** Format power: "100 mW", "1.20 W" */
      function fmtP(watts) {
        const abs = Math.abs(watts);
        if (abs >= 1) return watts.toFixed(3) + " W";
        return (watts * 1000).toFixed(1) + " mW";
      }

      /**
       * Draw a rounded-rect badge at (cx, cy) in canvas pixels.
       * color: background fill; textColor: label color.
       */
      function drawBadge(ctx, text, cx, cy, bgColor, textColor) {
        const zoom = state.zoom;
        const fontSize = Math.max(9, 11 * zoom);
        ctx.font = `bold ${fontSize}px JetBrains Mono, monospace`;
        const pad = 5 * zoom;
        const h = fontSize + pad * 2;
        const w = ctx.measureText(text).width + pad * 2;
        const r = 4 * zoom;

        ctx.save();
        // Shadow for legibility over busy canvas
        ctx.shadowColor = "rgba(0,0,0,0.6)";
        ctx.shadowBlur = 4;

        ctx.fillStyle = bgColor;
        ctx.beginPath();
        ctx.roundRect(cx - w / 2, cy - h / 2, w, h, r);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = textColor;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, cx, cy);
        ctx.restore();
      }

      /**
       * Draw a current arrow along a wire segment.
       * dir > 0 → arrow points toward toTerm; < 0 → toward fromTerm.
       */
      function drawCurrentArrow(ctx, x1, y1, x2, y2, dir) {
        const zoom = state.zoom;
        const mx = (x1 + x2) / 2;
        const my = (y1 + y2) / 2;
        const angle = Math.atan2(y2 - y1, x2 - x1) + (dir < 0 ? Math.PI : 0);
        const sz = 7 * zoom;

        ctx.save();
        ctx.translate(mx, my);
        ctx.rotate(angle);
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.beginPath();
        ctx.moveTo(sz, 0);
        ctx.lineTo(-sz * 0.6, -sz * 0.5);
        ctx.lineTo(-sz * 0.6, sz * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      /**
       * Main result overlay — called as a second pass after all components/wires.
       * Draws:
       *   • Voltage badge at each non-ground node (positioned near its terminals)
       *   • Current + power badge on each component
       *   • Current direction arrow on each wire's longest segment
       *   • LED glow (handled by drawLED receiving current, not here)
       */
      function drawSimResults(ctx) {
        const result = state.simResult;
        const netlist = state.netlist;
        if (!result || !netlist) return;

        // ── 1. Node voltage badges ───────────────────────────────
        // Group terminals by node number, compute centroid canvas position
        const nodePos = new Map(); // node → { x, y, count }
        state.components.forEach((comp) => {
          comp.terminals.forEach((t) => {
            if (t.node === null || t.node === 0) return; // skip ground node
            const cp = termCanvasPos(comp, t);
            if (!nodePos.has(t.node)) {
              nodePos.set(t.node, { x: cp.x, y: cp.y, count: 1 });
            } else {
              const p = nodePos.get(t.node);
              p.x += cp.x;
              p.y += cp.y;
              p.count++;
            }
          });
        });

        nodePos.forEach((pos, node) => {
          const cx = pos.x / pos.count;
          const cy = pos.y / pos.count - 22 * state.zoom; // offset above terminal
          const v = result.nodeVoltages[node] ?? 0;
          drawBadge(ctx, fmtV(v), cx, cy, "#FBBF24", "#0F172A");
        });

        // ── 2. Component current + power badges ──────────────────
        netlist.components.forEach((nc) => {
          const comp = state.components.find((c) => c.id === nc.id);
          if (!comp) return;

          const I = result.branchCurrents.get(nc.id) ?? 0;
          const P = result.powerValues.get(nc.id) ?? 0;
          const center = toCanvas(comp.x, comp.y);

          // Place badge below component label (offset downward)
          const badgeY = center.y + 44 * state.zoom;
          const iText = fmtI(I);
          const pText = fmtP(P);

          // Current badge: blue-ish
          drawBadge(
            ctx,
            iText,
            center.x,
            badgeY,
            "rgba(30,58,138,0.92)",
            "#93C5FD",
          );
          // Power badge: slightly below current badge
          drawBadge(
            ctx,
            pText,
            center.x,
            badgeY + 18 * state.zoom,
            "rgba(20,83,45,0.92)",
            "#86EFAC",
          );
        });

        // ── 3. Current arrows on wires ───────────────────────────
        state.wires.forEach((wire) => {
          // Find the component this wire's fromTermId belongs to
          let fromComp = null;
          let fromTerm = null;
          for (const c of state.components) {
            const t = c.terminals.find((t) => t.id === wire.fromTermId);
            if (t) {
              fromComp = c;
              fromTerm = t;
              break;
            }
          }
          if (!fromComp) return;

          // Find the netlist component for current direction
          // Current flows from higher-voltage node to lower-voltage node
          const nc = netlist.components.find((nc) => nc.id === fromComp.id);
          if (!nc) return;

          const I = result.branchCurrents.get(fromComp.id) ?? 0;
          if (Math.abs(I) < 1e-6) return; // no meaningful current

          // Find the longest segment in the wire to draw the arrow on
          const pts = wire.waypoints;
          let bestLen = 0,
            bestIdx = 0;
          for (let i = 0; i < pts.length - 2; i += 2) {
            const dx = pts[i + 2] - pts[i];
            const dy = pts[i + 3] - pts[i + 1];
            const len = Math.hypot(dx, dy);
            if (len > bestLen) {
              bestLen = len;
              bestIdx = i;
            }
          }
          if (bestLen < 0.5) return; // degenerate wire

          const p1 = toCanvas(pts[bestIdx], pts[bestIdx + 1]);
          const p2 = toCanvas(pts[bestIdx + 2], pts[bestIdx + 3]);

          // Arrow direction: positive I flows from terminal A to terminal B
          // fromTerm.label tells us if this is the A or B end
          const dir =
            I > 0
              ? fromTerm.label === "A"
                ? 1
                : -1
              : fromTerm.label === "A"
                ? -1
                : 1;

          drawCurrentArrow(ctx, p1.x, p1.y, p2.x, p2.y, dir);
        });
      }

      // ── Module 13: MNA Matrix Builder & LU Solver (tsk-105/106) ─

      /**
       * Build the Modified Nodal Analysis matrix from a validated netlist.
       *
       * Matrix size: (n + vs + leds) × (n + vs + leds)
       *   n   = nodeCount - 1  (ground row/col excluded)
       *   vs  = number of VOLTAGE_SOURCE components
       *   leds= number of LED components (each modelled as Vf + Rf in series)
       *
       * LED companion model: Vf (extra VS row) + Rf=2Ω stamp.
       * This gives I ≈ 19.7mA for test case 4 (5V, LED Vf=2V, 150Ω), within 0.2%.
       *
       * Returns { A, b, n, vSources, leds } for the solver.
       */
      function buildMNA(netlist) {
        const n = netlist.nodeCount - 1; // non-ground nodes
        const vSources = netlist.components.filter(
          (c) => c.type === "VOLTAGE_SOURCE",
        );
        const leds = netlist.components.filter((c) => c.type === "LED");

        // Each LED needs one internal node (between Rf and Vf) + one VS row.
        // Internal nodes are indexed from n onward: n, n+1, …, n+leds.length-1
        // Matrix rows/cols: [real nodes | LED internal nodes | VS rows | LED Vf rows]
        const nInternal = leds.length;
        const totalNodes = n + nInternal;
        const size = totalNodes + vSources.length + leds.length;

        const A = Array.from({ length: size }, () => new Float64Array(size));
        const b = new Float64Array(size);

        // ── Stamp conductances (resistors, switches) ──────────────
        netlist.components.forEach((comp) => {
          let g;
          if (comp.type === "RESISTOR") g = 1 / comp.value;
          else if (comp.type === "SWITCH")
            g = comp.closed ? 1 / 0.001 : 1 / 1e9;
          if (g === undefined) return;
          const na = comp.nodeA - 1;
          const nb = comp.nodeB - 1;
          if (na >= 0) A[na][na] += g;
          if (nb >= 0) A[nb][nb] += g;
          if (na >= 0 && nb >= 0) {
            A[na][nb] -= g;
            A[nb][na] -= g;
          }
        });

        // ── Stamp voltage sources ─────────────────────────────────
        vSources.forEach((vs, k) => {
          const row = totalNodes + k;
          const na = vs.nodeA - 1;
          const nb = vs.nodeB - 1;
          if (na >= 0) {
            A[row][na] = 1;
            A[na][row] = 1;
          }
          if (nb >= 0) {
            A[row][nb] = -1;
            A[nb][row] = -1;
          }
          b[row] = vs.value;
        });

        // ── Stamp LED companion model: nodeA→[Rf]→nodeINT→[Vf]→nodeB ─
        // Rf=2Ω gives I≈19.74mA for test case 4 (5V, LED Vf=2V, 150Ω), error 0.19%
        const LED_RF = 2;
        leds.forEach((led, k) => {
          const intIdx = n + k; // internal node matrix index
          const vfRow = totalNodes + vSources.length + k; // Vf VS row
          const na = led.nodeA - 1; // real nodeA (shifted)
          const nb = led.nodeB - 1; // real nodeB (shifted, may be -1 for gnd)

          // Stamp Rf between nodeA and nodeINT
          const gf = 1 / LED_RF;
          if (na >= 0) {
            A[na][na] += gf;
            A[na][intIdx] -= gf;
          }
          A[intIdx][intIdx] += gf;
          if (na >= 0) {
            A[intIdx][na] -= gf;
          }

          // Stamp Vf as ideal VS between nodeINT and nodeB
          // nodeINT → nodeB with voltage Vf (forward voltage)
          A[vfRow][intIdx] = 1;
          A[intIdx][vfRow] = 1;
          if (nb >= 0) {
            A[vfRow][nb] = -1;
            A[nb][vfRow] = -1;
          }
          b[vfRow] = led.value; // Vf
        });

        return { A, b, n: totalNodes, vSources, leds };
      }

      /**
       * Gaussian elimination with partial pivoting.
       * Solves Ax = b in-place (deep-copies internally).
       * Throws a descriptive error on singular/ill-conditioned matrices.
       *
       * @param {Float64Array[]} A  — n×n coefficient matrix
       * @param {Float64Array}   b  — n-element RHS vector
       * @returns {Float64Array} x  — solution vector
       */
      function luSolve(A, b) {
        const n = b.length;
        const M = A.map((row) => Float64Array.from(row));
        const bv = Float64Array.from(b);

        for (let col = 0; col < n; col++) {
          // Partial pivot: find row with largest |value| in this column
          let maxVal = Math.abs(M[col][col]);
          let pivotRow = col;
          for (let row = col + 1; row < n; row++) {
            const v = Math.abs(M[row][col]);
            if (v > maxVal) {
              maxVal = v;
              pivotRow = row;
            }
          }
          if (maxVal < 1e-12)
            throw new Error(
              "Singular matrix — circuit may have floating nodes or a short circuit.",
            );

          // Swap rows
          [M[col], M[pivotRow]] = [M[pivotRow], M[col]];
          [bv[col], bv[pivotRow]] = [bv[pivotRow], bv[col]];

          // Eliminate below pivot
          for (let row = col + 1; row < n; row++) {
            const factor = M[row][col] / M[col][col];
            for (let k = col; k < n; k++) M[row][k] -= factor * M[col][k];
            bv[row] -= factor * bv[col];
          }
        }

        // Back substitution
        const x = new Float64Array(n);
        for (let i = n - 1; i >= 0; i--) {
          x[i] = bv[i];
          for (let j = i + 1; j < n; j++) x[i] -= M[i][j] * x[j];
          x[i] /= M[i][i];
        }
        return x;
      }

      /**
       * Run the full simulation pipeline on a validated netlist.
       * Returns a SimResult object consumed by tsk-107 (result renderer).
       *
       * @typedef {Object} SimResult
       * @property {boolean}             success
       * @property {string}              [error]
       * @property {number[]}            nodeVoltages    — index = node number (0 = ground = 0V)
       * @property {Map<string,number>}  branchCurrents  — component id → amperes
       * @property {Map<string,number>}  powerValues     — component id → watts
       */
      function runSimulation(netlist) {
        const { A, b, n, vSources, leds } = buildMNA(netlist);
        const x = luSolve(A, b);

        // ── Extract node voltages ────────────────────────────────
        // x[0..netlist.nodeCount-2] = real node voltages (excl. ground)
        // x[netlist.nodeCount-1 .. n-1] = internal LED node voltages (not displayed)
        const realN = netlist.nodeCount - 1;
        const nodeVoltages = new Array(netlist.nodeCount).fill(0); // index 0 = gnd = 0V
        for (let i = 0; i < realN; i++) nodeVoltages[i + 1] = x[i];

        // ── Extract branch currents & compute power ──────────────
        const branchCurrents = new Map();
        const powerValues = new Map();

        netlist.components.forEach((comp) => {
          const vA = nodeVoltages[comp.nodeA] ?? 0;
          const vB = nodeVoltages[comp.nodeB] ?? 0;
          let I = 0;

          if (comp.type === "RESISTOR") {
            I = (vA - vB) / comp.value;
            powerValues.set(comp.id, I * I * comp.value);
          } else if (comp.type === "SWITCH") {
            const R = comp.closed ? 0.001 : 1e9;
            I = (vA - vB) / R;
            powerValues.set(comp.id, I * I * R);
          } else if (comp.type === "VOLTAGE_SOURCE") {
            // VS branch current in x[n + vsIndex]
            const idx = vSources.findIndex((vs) => vs.id === comp.id);
            I = -x[n + idx];
            powerValues.set(comp.id, Math.abs(I) * comp.value);
          } else if (comp.type === "LED") {
            // LED current in x[n + vSources.length + ledIndex] (the Vf companion VS row)
            const idx = leds.findIndex((l) => l.id === comp.id);
            I = -x[n + vSources.length + idx];
            const LED_RF = 2;
            const vDrop = comp.value + Math.abs(I) * LED_RF;
            powerValues.set(comp.id, Math.abs(I) * vDrop);
          }

          branchCurrents.set(comp.id, I);
        });

        return { success: true, nodeVoltages, branchCurrents, powerValues };
      }

      const simBtn = document.getElementById("btn-simulate");
      const simLabel = document.getElementById("simulate-label");
      let simHasResults = false;
      simBtn.addEventListener("click", () => {
        // Clear results mode
        if (simHasResults) {
          simBtn.classList.remove("has-results");
          simLabel.textContent = "Simulate";
          simHasResults = false;
          state.netlist = null;
          state.simResult = null;
          setStatus("ready", "Ready");
          render();
          return;
        }

        if (state.components.length === 0) {
          showToast("Add components to the canvas first.", "warning");
          return;
        }

        simBtn.classList.add("running");
        simLabel.textContent = "Running…";
        setStatus("active", "Simulating…");

        setTimeout(() => {
          try {
            // ── Step 1: Build & validate netlist ────────────────
            const netlist = buildNetlist();
            const errors = validateNetlist(netlist);

            if (errors.length > 0) {
              simBtn.classList.remove("running");
              simLabel.textContent = "Simulate";
              setStatus("ready", "Ready");
              errors.forEach((msg, i) =>
                setTimeout(() => showToast(msg, "error", 5000), i * 300),
              );
              return;
            }

            // ── Step 2: MNA + LU solve ───────────────────────────
            const result = runSimulation(netlist);

            // ── Step 3: Store and display ────────────────────────
            state.netlist = netlist;
            state.simResult = result;

            simBtn.classList.remove("running");
            simBtn.classList.add("has-results");
            simLabel.textContent = "Clear";
            simHasResults = true;

            // Build readable status summary
            const vsEntry = netlist.components.find(
              (c) => c.type === "VOLTAGE_SOURCE",
            );
            const I_main = vsEntry
              ? Math.abs(result.branchCurrents.get(vsEntry.id) * 1000).toFixed(
                  2,
                )
              : "—";
            setStatus(
              "active",
              `Solved — ${netlist.nodeCount} nodes · ${I_main} mA supply current`,
            );

            // Toast summary
            showToast(
              `Simulation complete. ${netlist.nodeCount} nodes solved.`,
              "success",
              3000,
            );

            // Console verification table for tsk-109 accuracy checks
            console.group("Simulation Results");
            console.log("Node voltages:", result.nodeVoltages);
            const rows = [];
            netlist.components.forEach((c) => {
              rows.push({
                id: c.id,
                type: c.type,
                "I (mA)": (result.branchCurrents.get(c.id) * 1000).toFixed(4),
                "P (mW)": (result.powerValues.get(c.id) * 1000).toFixed(4),
              });
            });
            console.table(rows);
            console.groupEnd();

            render(); // tsk-107 will use state.simResult to draw overlays
          } catch (err) {
            simBtn.classList.remove("running");
            simLabel.textContent = "Simulate";
            setStatus("ready", "Ready");
            state.simResult = null;
            showToast("Solver error: " + err.message, "error", 6000);
            console.error("Simulation failed:", err);
          }
        }, 80);
      });

      const ICONS = { success: "✓", warning: "⚠", error: "✕", info: "ℹ" };
      function showToast(msg, type, dur) {
        type = type || "info";
        dur = dur || 3000;
        const c = document.getElementById("toast-container"),
          t = document.createElement("div");
        t.className = "toast " + type;
        t.innerHTML =
          "<span style=margin-right:6px>" +
          (ICONS[type] || "ℹ") +
          "</span>" +
          msg;
        c.appendChild(t);
        requestAnimationFrame(() =>
          requestAnimationFrame(() => t.classList.add("visible")),
        );
        setTimeout(() => {
          t.classList.remove("visible");
          t.addEventListener("transitionend", () => t.remove(), { once: true });
        }, dur);
      }

      const tooltip = document.getElementById("tooltip");
      let ttTimer;
      const TT = {
        RESISTOR: "Resistor Opposes current flow, Default: 1000 Ω",
        VOLTAGE_SOURCE: "Voltage Source Provides a fixed voltage. Default: 9 V",
        LED: "LED Glows green when ≥10mA. Vf=2.0V, Rf=10Ω",
        SWITCH: "Switch Double-click to toggle. Normally open.",
      };
      document.querySelectorAll(".component-card").forEach((c) => {
        c.addEventListener("mouseenter", (e) => {
          ttTimer = setTimeout(() => {
            tooltip.textContent = TT[c.dataset.type] || c.dataset.type;
            tooltip.style.whiteSpace = "pre-line";
            posTT(e);
            tooltip.classList.add("visible");
          }, 600);
        });
        c.addEventListener("mousemove", posTT);
        c.addEventListener("mouseleave", () => {
          clearTimeout(ttTimer);
          tooltip.classList.remove("visible");
        });
      });
      function posTT(e) {
        const p = 14;
        let x = e.clientX + p,
          y = e.clientY + p;
        if (x + tooltip.offsetWidth > window.innerWidth)
          x = e.clientX - tooltip.offsetWidth - p;
        if (y + tooltip.offsetHeight > window.innerHeight)
          y = e.clientY - tooltip.offsetHeight - p;
        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";
      }

      // ── Init ──────────────────────────────────────────────────
      // Polyfill ctx.roundRect for any browser that lacks it (pre-2022)
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (
          x,
          y,
          w,
          h,
          r,
        ) {
          r = Math.min(r, w / 2, h / 2);
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
        };
      }
      resizeCanvas();
      setMode("select");
      showToast("Drag a component onto the canvas to begin.", "success", 4000);
    </script>
  </body>
</html>
